---
layout:     post   				    # 使用的布局（不需要改）
title:      Spring家族详解  		# 标题 
subtitle:           #副标题
date:      2020-04-27 		# 时间
author:     Haiming 						# 作者
header-img: img/post-bg-2015.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - Programming
    - Spring
---

参考资料：3y的文章

# 1. Spring AOP & IOC

## 1.1 是什么？有何特点？

IOC：依赖反转，解决的是对象管理和对象依赖的问题

AOP：面向切面编程，解决的是非业务代码抽取的问题。

## 1.2 怎么用？

1. IoC：我们将对象的依赖关系交给Spring，需要对象的时候就去Spring之中去取。

   好处：

   - **将对象统一管理，便于修改**
   - 降低耦合度（调用方无需自己在代码之中组装，也不需要关心对象如何实现，直接从【IOC容器】之中去取就可以。

   一般什么时候用：

   - 一般都是A对象之中有B对象的情况下使用
   - 比如用`@Component`注解标志将对象放入【IoC容器】，用`@Autowired`在代码之中将对象注入。(如果一个接口有多个实现类，可以配合`@Qualifier`来进行注入。

2. AOP：我们将非业务的代码交给Spring，只专注于业务代码。运行的时候会在也业务方法上面“动态织入”切面类型的代码。
   - 比如我们在搞一个数据库插入的代码， 那么需要连接数据库，插入，commit，将连接还给线程池等等。但是这些和我们的核心业务都没关系。那么如何简化呢？就是将这些代码直接抽取出来，需要的时候在“织进去”。
   - 那么“动态代理”，会让我们可以将对象“增强”，将非业务代码写在要【增强】的逻辑里面。之后，我们使用【增强之后的最想】来调用方法，这种方式就可以屏蔽掉重复代码。

![img](/img/640-20200427164427750)

上面这个图就是Spring AOP+IoC的一个例子：

1. 首先将UserDao标明`@Component`，告诉Spring：“我这个是要让你托管的类”
2. 然后从 `applicationContext` 里面去拿到这样的一个Bean，并且其将其作为**IUser**这个**接口**的实现。也可以看出，其对`save()`方法上面加入了具体的逻辑。
3. 我们对这个对象`getClass()`，看看其是什么class。
4. 直接调用这个接口——>使用的是Spring自动生成放在applicationContext里面的对象，并且将维护代码（@Before和@After）之中的代码已经动态的“植入”到了save()这个过程之中。

![img](/img/640.png)

这个就是结果。可以看到其class是`$proxy`，为代理生成。

# 2. Spring 入门

## 2.1 什么是Spring?

用来简化网络应用的开发。

1. 通过DI和面向接口实现松耦合
2. 基于**切面**进行声明式编程，减少样板式代码。

## 2.2 为什么要有Spring?

### 2.2.1 “前Spring"时代如何进行松耦合

可以使用面向接口编程，通过DaoFactory等实现松耦合。

```java
private CategoryDao categoryDao = DaoFactory.getInstance().createDao("zhongfucheng.dao.impl.CategoryDAOImpl", CategoryDao.class);

    private BookDao bookDao = DaoFactory.getInstance().createDao("zhongfucheng.dao.impl.BookDaoImpl", BookDao.class);

    private UserDao userDao = DaoFactory.getInstance().createDao("zhongfucheng.dao.impl.UserDaoImpl", UserDao.class);

    private OrderDao orderDao = DaoFactory.getInstance().createDao("zhongfucheng.dao.impl.OrderDaoImpl", OrderDao.class);
```

DAO不是直接生成，而是通过Factory去对应的类找对应的`DAOImpl`来完成。那么如果需要在Service 之中使用的时候：

![img](/img/640-20200427172651258)

比如这个，那么就实现了Service 和 DAO本身的解耦（中间使用Factory进行松耦合，修改的话只需要修改相应的`DAOImpl`,而不是需要在所有用到这个DAO的地方全部修改。

### 2.2.2 Spring如何实现松耦合

说白了，Factory不就是让创建对象的过程和使用对象的过程分开么？那我直接框架全给你生成，你需要时候自己过来取就好——Spring。

### 2.2.3 切面编程AOP

在第一部分已经讲了AOP是干嘛的，怎么使用。下面是一个Spring提供AOP的例子：

```java
    @Override
    @permission("添加分类")
    /*添加分类*/
    public void addCategory(Category category) {
        categoryDao.addCategory(category);
    }


    /*查找分类*/
    @Override
    public void findCategory(String id) {
        categoryDao.findCategory(id);
    }

    @Override
    @permission("查找分类")
    /*查看分类*/
    public List<Category> getAllCategory() {
        return categoryDao.getAllCategory();
    }

    /*添加图书*/
    @Override
    public void addBook(Book book) {
        bookDao.addBook(book);

    }
```

这里面的`@Permission`就是AOP，我们并不想每次都去写和业务无关的“判断权限”代码，那么就会动态织入这部分代码，然后将其生成之后的这个类传进来。

### 2.2.4 Spring IoC的好处？

1. 不需要自己组装，拿来就用
2. 单例，效率高，不浪费空间
3. 便于**单元测试和切换mock组件**：可以直接使用自己的mock组件对其做接口实现类的替换
4. 便于使用AOP操作，对于使用者透明
5. 统一配置，便于修改

## 2.3 Spring 怎么用？

### 2.3.1 得到Spring容器对象【IoC容器】

Spring之中的IoC容器不止一个：

1. BeanFactory，功能简单
2. ApplicationContext，功能强大【推荐使用】

**BeanFactory的获取：**

- 加载Spring配置文件
- 通过"XmlBeanFactory+配置文件“来创建IoC容器

```java
       //加载Spring的资源文件
        Resource resource = new ClassPathResource("applicationContext.xml");

        //创建IOC容器对象【IOC容器=工厂类+applicationContext.xml】
        BeanFactory beanFactory = new XmlBeanFactory(resource);
```

**类路径下XML获取ApplicationContext**

直接使用ClassPathXmlApplicationContext来获取

```java
        // 得到IOC容器对象
        ApplicationContext ac = new ClassPathXmlApplicationContext("applicationContext.xml");

        System.out.println(ac);
```

IoC之中一般有以下几种创建对象的方式：

1. 无参构造函数创建对象
2. 带参数的构造函数创建对象
3. 工厂创建对象
   1. 静态方法创建对象
   2. 非静态方法创建对象

带参数的构造函数创建对象：

```xml
    <bean id="user" class="User">

        <!--通过constructor这个节点来指定构造函数的参数类型、名称、第几个-->
        <constructor-arg index="0" name="id" type="java.lang.String" value="1"></constructor-arg>
        <constructor-arg index="1" name="username" type="java.lang.String" value="zhongfucheng"></constructor-arg>
    </bean>
```

### 2.3.2 使用注解方式得到对象

**1.使用注解的两种步骤：**

1. 在XML文件之中使用注解扫描器
2. 都用注解了，当然是做全套！直接在代码里面自定义扫描类`@ComponentScan`来扫描IoC容器的bean对象。这个注解一般情况下直接打在启动类上面。

**2. 创建对象和处理对象依赖关系相关的注解：**

1. @ComponentScan：扫描器
2. @Configuration：配置类
3. @Component：最常用，指定将一个对象放入IoC容器
4. @Repository, @Service,@controller这三个作用和@Component是一样的，只是程序员为了区分不同层次的代码，自己做的标记。
5. @Resource：直接看下面

### 2.3.3 @Autowired 和 @Resource区别

我们常用的就是这两个，其区别是：

1. @Autowired是Spring的注释，但是@Resource是JDK 1.6的注释
2. @Autowired 默认是通过类型装配，如果一个接口有多个符合的实现，可以使用@Qualifier进一步指定名字。@Resource 是默认通过名字装配

### 2.3.4 装配配置

因为Spring的自动装配并不能将第三方库装配到应用之中，所以需要显式装配配置。显示装配有两种方式：通过Java代码和XML。一般都是使用Java代码配置。

如何通过Java代码配置Bean？

