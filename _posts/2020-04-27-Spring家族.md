---
layout:     post   				    # 使用的布局（不需要改）
title:      Spring家族详解  		# 标题 
subtitle:           #副标题
date:      2020-04-27 		# 时间
author:     Haiming 						# 作者
header-img: img/post-bg-2015.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - Programming
    - Spring
---

# 1. Spring AOP & IOC

## 1.1 是什么？有何特点？

IOC：依赖反转，解决的是对象管理和对象依赖的问题

AOP：面向切面编程，解决的是非业务代码抽取的问题。

## 1.2 怎么用？

1. IoC：我们将对象的依赖关系交给Spring，需要对象的时候就去Spring之中去取。

   好处：

   - **将对象统一管理，便于修改**
   - 降低耦合度（调用方无需自己在代码之中组装，也不需要关心对象如何实现，直接从【IOC容器】之中去取就可以。

   一般什么时候用：

   - 一般都是A对象之中有B对象的情况下使用
   - 比如用`@Component`注解标志将对象放入【IoC容器】，用`@Autowired`在代码之中将对象注入。(如果一个接口有多个实现类，可以配合`@Qualifier`来进行注入。

2. AOP：我们将非业务的代码交给Spring，只专注于业务代码。运行的时候会在也业务方法上面“动态织入”切面类型的代码。
   - 比如我们在搞一个数据库插入的代码， 那么需要连接数据库，插入，commit，将连接还给线程池等等。但是这些和我们的核心业务都没关系。那么如何简化呢？就是将这些代码直接抽取出来，需要的时候在“织进去”。
   - 那么“动态代理”，会让我们可以将对象“增强”，将非业务代码写在要【增强】的逻辑里面。之后，我们使用【增强之后的最想】来调用方法，这种方式就可以屏蔽掉重复代码。

![img](/img/640-20200427164427750)

上面这个图就是Spring AOP+IoC的一个例子：

1. 首先将UserDao标明`@Component`，告诉Spring：“我这个是要让你托管的类”
2. 然后从 `applicationContext` 里面去拿到这样的一个Bean，并且其将其作为**IUser**这个**接口**的实现。也可以看出，其对`save()`方法上面加入了具体的逻辑。
3. 我们对这个对象`getClass()`，看看其是什么class。
4. 直接调用这个接口——>使用的是Spring自动生成放在applicationContext里面的对象，并且将维护代码（@Before和@After）之中的代码已经动态的“植入”到了save()这个过程之中。

![img](/img/640.png)

这个就是结果。可以看到其class是`$proxy`，为代理生成。

# 2. Spring 入门

## 2.1 什么是Spring?

用来简化网络应用的开发。

1. 通过DI和面向接口实现松耦合
2. 基于**切面**进行声明式编程，减少样板式代码。

## 2.2 为什么要有Spring?

### 2.2.1 “前Spring"时代如何进行松耦合

可以使用面向接口编程，通过DaoFactory等实现松耦合。

```java
private CategoryDao categoryDao = DaoFactory.getInstance().createDao("zhongfucheng.dao.impl.CategoryDAOImpl", CategoryDao.class);

    private BookDao bookDao = DaoFactory.getInstance().createDao("zhongfucheng.dao.impl.BookDaoImpl", BookDao.class);

    private UserDao userDao = DaoFactory.getInstance().createDao("zhongfucheng.dao.impl.UserDaoImpl", UserDao.class);

    private OrderDao orderDao = DaoFactory.getInstance().createDao("zhongfucheng.dao.impl.OrderDaoImpl", OrderDao.class);
```

DAO不是直接生成，而是通过Factory去对应的类找对应的`DAOImpl`来完成。那么如果需要在Service 之中使用的时候：

![img](/img/640-20200427172651258)

比如这个，那么就实现了Service 和 DAO本身的解耦（中间使用Factory进行松耦合，修改的话只需要修改相应的`DAOImpl`,而不是需要在所有用到这个DAO的地方全部修改。

### 2.2.2 Spring如何实现松耦合

说白了，Factory不就是让创建对象的过程和使用对象的过程分开么？那我直接框架全给你生成，你需要时候自己过来取就好——Spring。

### 2.2.3 切面编程AOP



## @Autowired 和 @Resource区别

