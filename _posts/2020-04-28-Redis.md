---
layout:     post   				    # 使用的布局（不需要改）
title:      Redis综合梳理  		# 标题 
subtitle:           #副标题
date:      2020-04-28 		# 时间
author:     Haiming 						# 作者
header-img: img/post-bg-2015.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - Programming
    - Redis
---

还是看3y的公众号总结。

# 1. Redis底层数据结构实现

![img](../img/640-20200428155337295.jpeg)

Redis底层是K-V对，其键值只能是String，但是Value可以是以下五种形式。

其创建一个新的K-V对的时候，K和V会分开创建，也就是说一次创建两个对象。

## 1.1 String

在上面的图我们知道string类型有三种**编码格式**：

- int：整数值，这个整数值可以使用long类型来表示

- - 如果是浮点数，那就用embstr或者raw编码。具体用哪个就看这个数的长度了

- embstr：字符串值，这个字符串值的长度小于32字节

- raw：字符串值，这个字符串值的长度大于32字节

embstr和raw的**区别**：

- raw分配内存和释放内存的次数是两次，embstr是一次
- embstr编码的数据保存在一块**连续**的内存里面

编码之间的**转换**：

- int类型如果存的**不再是一个整数值**，则会从int转成raw
- embstr是只读的，在修改的时候回从embstr转成raw

## 1.2 list对象

根据长度不一样有不同的编码格式，比如：

- ziplist: 字符串的元素长度都小于64个字节，并且总数量小于512个
- linkedlist：字符串的元素长度大于64字节，或者总数量大于512个

ziplist编码的list结构：

![img](../img/640-20200428155527953)

linkedlist编码的list结构：

![img](../img/640-20200428155558220.jpeg)

**而且原本是ziplist编码的，如果其保存的长度太大，或者是元素的数量过多，就会转换成linkedlist。**

## 1.3 Hash对象

根据长度不一样也有两种编码格式：

1. ziplist：key 和 value的字符串长度都小于64字节，并且K-V对的数量小于512
2. hashtable：key和value的字符串长度大于64字节，或者其K-V对的数量大于512

ziplist:

![img](../img/640-20200428155823704)

hashtable编码的hash结构：

![img](../img/640-20200428155847447)

**原本是ziplist编码的，如果保存的数据长度太大，或者元素数量过多，会转换成hashtable编码的。**

## 1.4 Set对象

根据不同长度还是有两种编码格式：

1. intset:保存的元素全是整数，且总数量小于512
2. hashtable：保存的元素不是整数，或者总数量大于512.

intset编码的集合结构：

![img](../img/640-20200428160223855)

hashtable编码的集合结构：

![img](../img/640-20200428160238933.jpeg)

**原本是intset编码的，如果保存的数据不是整数值或者元素数量大于512，会转换成hashtable编码的。**

## 1.5 zset对象

有两种编码格式：

1. ziplist:元素长度小于64，且总数量小于128
2. skiplist：元素长度大于64或者总数量大于128

ziplist的zset结构：

![img](../img/640-20200428160519631)

skiplist的zset结构：

![img](../img/640-20200428160532552)

# 2. Redis的数据库

