---
layout:     post   				    # 使用的布局（不需要改）
title:      Java 之中的泛型和类型擦除  		# 标题 
subtitle:           #副标题
date:       2019-12-19		# 时间
author:     Haiming 						# 作者
header-img: img/post-bg-2015.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - 编程
    - 泛型
---

参考：https://blog.csdn.net/xiangwanpeng/article/details/77896340

https://blog.csdn.net/s10461/article/details/53941091

本文的顺序是先讲泛型，然后讲关于类型擦除的问题。

# 泛型

## 概述

首先要解决的问题：什么是泛型？为什么要使用泛型？

这是网上一段内容的引用：

> 泛型，就是“参数化类型”。 我们在讲到参数的情况时，一般讲的都是在定义方法的时候定义的形参，然后在使用的时候传入实参。
>
> 那么”参数化类型“就很好理解了： 将类型由原来的具体类型进行参数化， 类似于方法之中的变量参数，将类型也定义成变量形式。只是在使用方法的时候传入具体的类型（类型实参）
>
> 泛型本质是参数化类型，在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型。这种参数类型可以用在类型，接口和方法之中，分别称为泛型类，泛型接口和泛型方法。

## 举2个例子

下面两个例子的输出不同，下面会详细叙述其原因。

首先这个例子可以说明泛型的作用：

```java
package GenericStudy;

import java.util.ArrayList;
import java.util.List;

public class GenerateTesting {
    public static void main(String[] args) {
        List arrayList=new ArrayList();
        arrayList.add("abcd");
        arrayList.add(1234);

        for(int i =0;i<arrayList.size();i++){
            String item = arrayList.get(i);
            System.out.println("Testing generic: "+item);
        }

    }
}

```

输出为：

```java
Testing generic: abcd
Exception in thread "main" java.lang.ClassCastException: java.lang.Integer incompatible with java.lang.String
	at GenericStudy.GenerateTesting.main(GenerateTesting.java:13)
```

首先，此处的错误的确显而易见：将arrayList之中第二个Integer对象cast成String，那么肯定是会出问题的。但是这处在编译阶段并没有报错。而为了对于的 List<> 这样类型的对象，希望可以在编译阶段就解决，那么泛型就应运而生了。

下面是我自己改过的代码：

```java
package GenericStudy;

import java.util.ArrayList;
import java.util.List;

public class GenerateTesting {
    public static void main(String[] args) {
        List arrayList=new ArrayList();
        arrayList.add("abcd");
        arrayList.add(1234);

        for(int i =0;i<arrayList.size();i++){
            Object item = arrayList.get(i);
            System.out.println("Testing generic: "+item);
        }

    }
}

```

 结果是：

```java
Testing generic: abcd
Testing generic: 1234
```

此处运行正常，原因是使用Object类来接住遍历的对象，然后对其直接进行操作。

## 特性

泛型只在编译阶段有效，下面的代码为例：

CheckArrayListType.java

```java
package GenericStudy;

import java.util.ArrayList;

public class CheckArrayListType {
    public static void main(String[] args) {
        ArrayList<String> arrayList1 = new ArrayList<>();
        arrayList1.add("abcde");
        ArrayList<Integer> arrayList2 = new ArrayList<>();
        arrayList2.add(12345);
        ArrayList<Object> arrayList3 = new ArrayList<>();
        arrayList3.add(123433);
        arrayList3.add("hahahaha");
        System.out.println(arrayList3);
        /*
        Here will show that below is always true
         */
        System.out.println(arrayList1.getClass() == arrayList2.getClass());
    }
}

```

在最下面这一行，会出现这样的提示：

![Screenshot 2019-12-27 at 6.19.28 PM](../img/Screenshot 2019-12-27 at 6.19.28 PM.png)

程序在编译之后，会采取去泛型化的特征，也就是Java 之中所说的泛型，只在编译阶段有效。

在编译过程中，**正确检验泛型结果**之后，会将泛型相关的信息全部擦除，并且在对象进入和厉害方法的边界处添加**类型检查**和**类型转换**的方法。也就是说，泛型信息不会进入到运行时阶段。

总结：泛型类型在逻辑上可以看成是多个不同的类型，实际都是相同的类型。

## 泛型的使用

泛型有三种使用方式：泛型类，泛型接口，泛型方法。

#### 泛型类

