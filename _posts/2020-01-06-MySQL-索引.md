---
layout:     post   				    # 使用的布局（不需要改）
title:      MySQL之中索引的部分知识  		# 标题 
subtitle:   包含某些MySQL的面试题目解析        #副标题
date:       2020-01-06		# 时间
author:     Haiming 						# 作者
header-img: img/post-bg-2015.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - 编程
    - MySQL
---

参考：

[http://huyan.couplecoders.tech/mysql/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E9%AB%98%E6%80%A7%E8%83%BDmysql/2019/06/01/Mysql%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E4%BC%98%E5%8C%96/](http://huyan.couplecoders.tech/mysql/读书笔记/高性能mysql/2019/06/01/Mysql索引原理及其优化/)

在日常生活之中，MySQL的索引原理还是非常重要的，也是一个程序很多时候的瓶颈所在。本文会梳理包括MySQL 索引和其他的一些MySQL 知识，下面就开始讲。

# 什么是索引

先上定义：

**索引是存储引擎用于快速找到记录的一种数据结构。**

啥意思呢？

说白了，空间换时间。

索引通过额外的空间占用，类似于目录一样，对某些数据进行了重新排序和整理，这样才能够在查找的时候进行比较快速的寻找。

其关键就是对于某些数据的重新排序。我们都知道，在一个数据表之中，数据是有天然的ID的。如果我们按照这个默认的ID，也就是插入顺序来查找某些数据，除了遍历之外别无他法。但是如果我们对某些经常查询的数据进行重新排序，那么在再次查找的时候，就可以通过二分法`复杂度 O(logn)`来快速得到这个值的具体位置，然后通过随机存储直接得到这个数据的完整条目。

而MySQL使用的是B+树，在效率上面比单纯的线性链表式索引效率要更高。

> 所谓「随机访问」，指的是当存储器中的讯息被读取或写入时，所需要的时间与这段信息所在的位置无关。相对的，存取顺序访问（Sequential Access）存储设备中的信息时，其所需要的时间与位置就会有关系（如磁带）。

# 索引的优缺点？

#### 索引的优点

首先，按照上面我们所说的，索引可以帮我们快速的找到数据。其次，因为索引之中的数据是顺序储存，所以可以帮我们进行orderby 的操作。第三，索引之中虽然只是部分，但是其中也是存储了真正的值的，部分查询可以直接在索引之中完成，不需要去查大表。

总结了一下，索引的优点就是：

- 减少查询所需要扫描的数据量（加快了查询速度）
- 减少服务器的排序操作和创建临时表的操作（加快了groupby和orderby的操作）
- 将服务器的随机IO变为顺序IO（加快了查询速度）

#### 索引的缺点

之前我们讲过，索引是用空间换时间，那么节省了时间肯定是要从空间上面找补回来的。

索引的主要缺点也就是在空间方面。

索引，按照我们之前讲的，也就是一张额外的表格。其也需要存储，因此会带来额外的空间占用。其次，在插入，更新和删除操作的同时，对这个索引表格也要进行进一步的维护，要有额外的时间开销。

总结如下：

- 索引占用磁盘或者内存空间
- 减慢了插入更新操作的速度

实际生产环境之中，在一定数据范围之内，建立索引的开销是远远小于其带来的好处的。

# 索引类型

对MySQL而言，其索引是在存储引擎部分实现的，因此不同的存储引擎所实现的索引也不太一样。InnoDB目前是使用最广泛的引擎，使用的索引是B+树，因此大部分时间的索引也都是他。

MySQL目前有以下几种索引：

- B-树索引 / B+ 树索引
- 哈希索引
- 空间数据索引
- 全文索引

本文之中只探讨 B- 树索引和 B+ 树索引之间的不同与其带来的好处：

B+树在B树上面加上了以下的限制：

1. 每个中间节点不保存数据，这意味着所有非叶子节点的数据都被保存了一份放在叶子节点之中
2. 叶子结点在B-树的基础之上按照自身的顺序进行了连接。

这样的好处有什么呢？

1. 中间节点不保存数据了，那么相对于B树而言，每一个非叶子节点其可以存储的数据更多，那么树的层级就更少，其查询数据更快
2. B+树的查询速度更稳定：因为所有关键字的数据地址都存储在叶子节点上面，所以其每次查找的速度都相同，相比而言更加稳定
3. 所有叶子节点按照顺序链组成了链表，**因此可以更方便的进行范围查询**

**其中第三点是最重要的！ 这也是为什么B+树在查找某一节点的时候速度其实是比B树慢，但是仍然被InnoDB所使用的原因！**

# 怎么创建高性能的索引？

因为优化索引和优化查询一般是分不开的，因此这里会包含部分的查询优化。

## 前缀索引和索引选择性

如果是给一个很长的字符串上面加上索引，可以考虑使用前缀索引。

数据库在使用索引进行查找的时候，主要是分以下两步：

1. 在索引的B+树上面找到对应的查找的值，比如找到名字是”abcdefghijk"的一条记录，并且拿到这条数据在磁盘上面的地址
2. 根据地址去磁盘上面查找该记录，并且将该记录取出。

这就涉及到我们所说的前缀索引是否可以优化该记录了：

如果我们发现，其实"abcde"在这个数据表之中就已经是唯一的数据，那么我们使用“abcde“来作为该数据的索引，是不是可以起到和”abcdefghijk“一样的效果？

那么此时我们就完成了一次”前缀索引“。而且我们发现，其长度远远小于完整数据的长度。这就是前缀索引的作用。

> 索引的选择性： （不重复的值）/（所有的值）， 那么可以看出来，索引的选择性的值可选范围为0-1，0的情况为所有的值都有一条或更多的重复值，而1的情况为所有的值都互不重复，都是独立的值。

**前缀索引：**

在对一个比较长的字符串做索引的时候，可以只选择其中的一部分字符，从而提高索引效率。但是这样也会降低我们刚才所说的，”索引的选择性“。

我觉得这个概念还是比较容易理解，毕竟短的字符串肯定比长的字符串更容易重复，那么我们截取其中的一部分，当然其选择性会降低。

我们使用下面的方法来算出来一些前缀的选择性，比如：

```sql
select 
    count(distinct left(school_name,3))/count(*) as sch3, 
    count(distinct left(school_name,4))/count(*) as sch4,
    count(distinct left(school_name,5))/count(*) as sch5,
    count(distinct school_name)/count(*) as original
from 
    user;
```

前三个语句分别是取其前3，4，5个字符作为索引的时候其选择性。如果我们慢慢增大这个数值，在其和第四个（原本的选择性）差别不大的时候，就是一个比较合适的前缀索引的长度了。

选择好长度之后，就可以创建一个前缀索引了：

```sql
alter table user add index sch_pre3(`school(3)`)
```

## 联合索引

<font face="黑体">我是黑体字</font> 

<font color=#0099ff size=12 face="黑体">黑体</font> 

