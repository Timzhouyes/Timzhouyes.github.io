---
llayout:     post   				    # 使用的布局（不需要改）
title:      学习Go语言				# 标题 
subtitle:   阅读《The way to Go》  #副标题
date:       2019-10-15 				# 时间
author:     Haiming 						# 作者
header-img: img/post-bg-2015.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - 编程
    - Go
---

趁着在间隙的时间，把Go入个门。虽说语言只是工具，但是学学也是比不学要好。
阅读环境在：https://github.com/unknwon/the-way-to-go_ZH_CN/blob/master/eBook/directory.md
作者的中文译本是经过官方授权的，不必担心版权问题。
话不多说。实战。

# 前言

本书由这样几部分组成：

- Go语言起源和开发环境
- Go语言核心思想，包括简单与复杂类型（第 4、7、8 章），控制结构（第 5 章），函数（第 6 章），结构与方法（第 10 章）和接口（第 11 章）。我们会对 Go 语言的函数式和面向对象编程进行透彻的讲解，包括如何使用 Go 语言来构造大型项目（第 9 章）。
- 使用Go处理不同格式文件和错误处理机制，以及分布式的网络技巧
- Go语言的开发模式和编码规范。

# 第一章：Go语言的起源，发展与普及

## 1.2.3 Go 语言的发展目标

Go的目标是将静态语言的安全性，高效性；和动态语言的易开发性进行有机结合。

Go是一门类型安全和内存安全的编程语言。Go有指针，但是不允许指针运算。

Go的另一个目标是对于网络通信，并发和并行编程的极佳支持。从而更好的利用大量的分布式和多核的计算机。众所周知，谷歌内部的服务器不是大型机，而是很多台普通服务器进行服务。所以这一点要求完全符合Google内部的业务需求。

Go的构建速度很快，编译和链接的速度只要几百毫秒到几秒。

Go语言的依赖关系采用的是包模型。

## 1.2.5 语言的特性

Go语言从本质上，在程序和结构方面支持并发编程。

Go没有类和继承的概念，其通过实现接口（interface）的概念来实现多态性。

函数是Go语言之中的基本构件。

Go语言使用静态类型，所以其是类型安全的一门语言。

Go是强类型语言，隐式的类型转换是不被允许的。

Go支持交叉编译，例如在Linux的计算机上面开发运行在Windows下面的程序。

## 1.2.6 语言的用途

Go的主要用途是用来应用于搭载Web服务器，存储集群或者类似用途的巨型中央服务器的系统编程语言。其主要支持的是高性能分布式系统。

Go语言的一个目标是实现CEP，即复杂事件处理。其要求海量的并行支持，高度的抽象化和高性能。其在IoT时代非常需要。

Go不适合用来开发对实时性要求很高的软件，原因是其垃圾回收和自动内存分配的机制有问题。

## 1.2.7 关于特性缺失

许多能够在大多数面向对象语言中使用的特性 Go 语言都没有支持，但其中的一部分可能会在未来被支持。

- 为了简化设计，不支持函数重载和操作符重载
- 为了避免在 C/C++ 开发中的一些 Bug 和混乱，不支持隐式转换
- Go 语言通过另一种途径实现面向对象设计（第 10-11 章）来放弃类和类型的继承
- 尽管在接口的使用方面（第 11 章）可以实现类似变体类型的功能，但本身不支持变体类型
- 不支持动态加载代码
- 不支持动态链接库
- 不支持泛型
- 通过 `recover` 和 `panic` 来替代异常机制（第 13.2-3 节）
- 不支持静态变量

# 第2章：安装与运行环境

##  2.1 平台与架构

1. Go原生编译器gc：

   这款编译器使用非分代、无压缩和并行的方式进行编译，它的编译速度要比 gccgo 更快，产生更好的本地代码，但编译后的程序不能够使用 gcc 进行链接。

   编译器目前支持以下基于 Intel 或 AMD 处理器架构的程序构建。

   [![img](../img/2.1.gc.jpg)](https://github.com/unknwon/the-way-to-go_ZH_CN/blob/master/eBook/images/2.1.gc.jpg?raw=true)

   表格之中的 g 和 l 的意义如下：

   ```Go
    g = 编译器：将源代码编译为项目代码（程序文本）
    l = 链接器：将项目代码链接到可执行的二进制文件（机器代码）
   ```

   下面的标记是指可以通过命令行设置可选参数，来影响编译器或者链接器的构建过程，或者得到一个特殊的目标结果。

   可用的编译器标记如下：

   ```Go
    flags:
    -I 针对包的目录搜索
    -d 打印声明信息
    -e 不限制错误打印的个数
    -f 打印栈结构
    -h 发生错误时进入恐慌（panic）状态
    -o 指定输出文件名 // 详见第3.4节
    -S 打印产生的汇编代码
    -V 打印编译器版本 // 详见第2.3节
    -u 禁止使用 unsafe 包中的代码
    -w 打印归类后的语法解析树
    -x 打印 lex tokens
   ```

   从 Go 1.0.3 版本开始，不再使用 8g，8l 之类的指令进行程序的构建，取而代之的是统一的 `go build` 和 `go install` 等命令，而这些指令会自动调用相关的编译器或链接器。即这两个命令在所有情况之下通用。

2. gccgo 编译器：

   一款相对于 gc 而言更加传统的编译器，使用 GCC 作为后端。GCC 是一款非常流行的 GNU 编译器，它能够构建基于众多处理器架构的应用程序。编译速度相对 gc 较慢，但产生的本地代码运行要稍微快一点。它同时也提供一些与 C 语言之间的互操作性。

   从 Go 1 版本开始，gc 和 gccgo 在编译方面都有等价的功能。

3. 文件扩展名与包（package）：

   Go 语言源文件的扩展名很显然就是 `.go`。

   C 文件使用后缀名 `.c`，汇编文件使用后缀名 `.s`。所有的源代码文件都是通过包（packages）来组织。包含可执行代码的包文件在被压缩后使用扩展名 `.a`（AR 文档）。

   Go 语言的标准库（第 9.1 节）包文件在被安装后就是使用这种格式的文件。

   **注意 当你在创建目录时，文件夹名称永远不应该包含空格，而应该使用下划线 "_" 或者其它一般符号代替。**

## 2.2 Go环境变量

这里列举几个最为重要的环境变量：

- **$GOROOT** 表示 Go 在你的电脑上的安装位置，它的值一般都是 `$HOME/go`，当然，你也可以安装在别的地方。
- **$GOARCH** 表示目标机器的处理器架构，它的值可以是 386、amd64 或 arm。
- **$GOOS** 表示目标机器的操作系统，它的值可以是 darwin、freebsd、linux 或 windows。
- **$GOBIN** 表示编译器和链接器的安装位置，默认是 `$GOROOT/bin`，如果你使用的是 Go 1.0.3 及以后的版本，一般情况下你可以将它的值设置为空，Go 将会使用前面提到的默认值。

Go还支持交叉编译，也就是可以在一台机器上面构件运行在具有不同操作系统和处理器架构上面运行的应用程序。即编写源代码的机器可以和目标机器有完全不同的特性。

为了区分本地机器和目标机器，你可以使用 `$GOHOSTOS` 和 `$GOHOSTARCH` 设置本地机器的操作系统名称和编译体系结构，这两个变量只有在进行交叉编译的时候才会用到，如果你不进行显示设置，他们的值会和本地机器（`$GOOS` 和 `$GOARCH`）一样。

- **$GOPATH** 默认采用和 `$GOROOT` 一样的值，但从 Go 1.1 版本开始，你必须修改为其它路径。它可以包含多个 Go 语言源码文件、包文件和可执行文件的路径，而这些路径下又必须分别包含三个规定的目录：`src`、`pkg` 和 `bin`，这三个目录分别用于存放源码文件、包文件和可执行文件。

- **$GOARM** 专门针对基于 arm 架构的处理器，它的值可以是 5 或 6，默认为 6。

- **$GOMAXPROCS** 用于设置应用程序可使用的处理器个数与核数，详见第 14.1.3 节。

## 2.6 安装目录清单

你的 Go 安装目录（`$GOROOT`）的文件夹结构应该如下所示：

README.md, AUTHORS, CONTRIBUTORS, LICENSE

- `/bin`：包含可执行文件，如：编译器，Go 工具
- `/doc`：包含示例程序，代码工具，本地文档等
- `/lib`：包含文档模版
- `/misc`：包含与支持 Go 编辑器有关的配置文件以及 cgo 的示例
- `/os_arch`：包含标准库的包的对象文件（`.a`）
- `/src`：包含源代码构建脚本和标准库的包的完整源代码（Go 是一门开源语言）
- `/src/cmd`：包含 Go 和 C 的编译器和命令行脚本

## 2.7 Go运行时（runtime）

虽然说Go产生的是本地可执行代码，这些代码仍然运行在Go的runtime 之中，其类似于JVM等虚拟机，负责管理包括内存分配。垃圾回收，栈处理，goroutine，channel，。slice，map和反射（reflection）等等。

Go 的垃圾回收器是使用 标记-清除 垃圾回收器。

## 2.8 Go 解释器

因为 Go 具有像动态语言那样快速编译的能力，自然而然地就有人会问 Go 语言能否在 REPL（read-eval-print loop）编程环境下实现。Sebastien Binet 已经使用这种环境实现了一个 Go 解释器。

[REPL]([https://zh.wikipedia.org/wiki/%E8%AF%BB%E5%8F%96%EF%B9%A3%E6%B1%82%E5%80%BC%EF%B9%A3%E8%BE%93%E5%87%BA%E5%BE%AA%E7%8E%AF](https://zh.wikipedia.org/wiki/读取﹣求值﹣输出循环)) 的意思是 **“读取-求值-输出”循环**（英语：**Read-Eval-Print Loop**，简称**REPL**。 这个机制可以对用户的输入立刻作出反应。

# 第3章：编辑器、集成开发环境与其它工具

## 3.3 调试器

Go的调试器还不是很完善，下面几种方法可以作为部分的替代：

1. 在合适的位置使用打印语句输出相关变量的值（`print`/`println` 和 `fmt.Print`/`fmt.Println`/`fmt.Printf`）。
2. 在 `fmt.Printf` 中使用下面的说明符来打印有关变量的相关信息：
   - `%+v` 打印包括字段在内的实例的完整信息
   - `%#v` 打印包括字段和限定类型名称在内的实例的完整信息
   - `%T` 打印某个类型的完整说明
3. 使用 panic 语句（第 13.2 节）来获取栈跟踪信息（直到 panic 时所有被调用函数的列表）。
4. 使用关键字 defer 来跟踪代码执行过程（第 6.4 节）。3.4 构建并运行 Go 程序

## 3.4 构建并运行 Go 程序

在构建程序之前，会自动调用格式化工具 gofmt 并且保存格式化之后的源文件。如果一切执行顺利并且成功退出之后，会在控制台输出 `Program exited with code 0	`

从 Go 1 版本开始，使用 Go 自带的工具来构建应用程序

- `go build` 编译自身包和依赖包
- `go install` 编译并安装自身包和依赖包

## 3.5 格式化代码

