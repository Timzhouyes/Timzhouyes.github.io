---
layout:     post   				    # 使用的布局（不需要改）
title:      Redis 的 key 乱码问题  		# 标题 
subtitle:   成因以及如何解决        #副标题
date:       2021-05-21		# 时间
author:     Haiming 						# 作者
header-img: img/post-bg-2015.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - Programming
    - Redis
---

参考：https://blog.csdn.net/m4330187/article/details/108091447

https://blog.csdn.net/Abysscarry/article/details/80557347

https://www.cnblogs.com/54chensongxia/p/13815761.html

今天在自己做本机部署 redis 测试的时候，发现下面的问题：在拿取键的时候，其值有一个前缀,类似`\xac\xed\x00\x05t\x00`

![image-20210521103214326](/img/2021-05-21-Redis-key-乱码/image-20210521103214326.png)

那么这种是如何出现的呢？参照这一篇 blog 的内容，可以发现其原因是：

> 在spring 项目之中使用redis，我们需要在maven 之中引入 `spring-data-redis`。但是这个里面的***\*RedisTemplate<K, V>模板类\****， 在序列化的时候默认是使用 JdkSerializationRedisSerializer。 但是如果我们使用 jedis 作为 redis 的客户端，jedis 在交互的时候是使用 byte 类型，而我们再看，上面引入的类型，RedisTemplate 之中的 V 是一个泛型，而不是一个 byte 类型。
>
> 这就造成了默认情况下，使用 JdkSerializationRedisSerializer 来进行序列化操作，那么就会出现乱码。

文中的三种解决办法：

1. 直接在定义 redisTemplate 的时候就将泛型定义成 `RedisTemplate<String, String>`，这样就会使用`StringRedisSerializer()`。
2. 在 redisConfig 里面，指定生成 redisTemplate 的时候的序列化方式：

```java

@Configuration
public class RedisConfig {
 
    @Bean(name = "redisTemplate")
    public RedisTemplate<Object, Object> redisTemplate(RedisConnectionFactory factory) {
        RedisTemplate<Object, Object> template = new RedisTemplate<>();
        RedisSerializer<String> redisSerializer = new StringRedisSerializer();
 
        template.setConnectionFactory(factory);
        //key序列化方式
        template.setKeySerializer(redisSerializer);
        //value序列化
        template.setValueSerializer(redisSerializer);
        //value hashmap序列化
        template.setHashValueSerializer(redisSerializer);
        //key haspmap序列化
        template.setHashKeySerializer(redisSerializer);
        
        return template;
    }
```

3. 直接定义的时候就用 StringRedisTemplate 类，而不是 RedisTemplate。

# 个人补充, jedis 和 lettuce 对比

当然还有我个人补充的点：

在maven 之中，我们还可以使用官方的`spring-boot-starter-data-redis`。在这个之中，是将 jedis 替换成了 lettuce 作为 redis 的客户端。

可以从这里得知：

https://www.cnblogs.com/54chensongxia/p/13815761.html

**Jedis**

比较老牌，对于Redis 的命令支持比较全面，但是其

1. 使用阻塞的 IO，同步的调用方法在程序流等到 socket 执行完 I/O 才能执行，不支持异步
2. 其本地会有线程不安全的问题，所以要使用**连接池**

**lettuce**

其底层基于 Netty，也支持高级 Redis 特性，其优点是：

1. 支持同步异步通信模式
2. Lettuce 的API 是线程安全的，在**不是执行阻塞和事务操作的情况下**，多个线程可以共享一个连接

## Redis 客户端通信协议

Redis制定了RESP（Redis Serialization Protocol，Redis序列化协议）实现客户端与服务端的正常交互，这种协议简单高效，既能够被机器解析，又容易被人类识别。

`RESP`可以序列化不同的数据类型，如整型、字符串、数组还有一种特殊的`Error`类型。需要执行的`Redis`命令会封装为类似于**字符串数组**的请求然后通过`Redis`客户端发送到`Redis`服务端。`Redis`服务端会基于特定的命令类型选择对应的一种数据类型进行回复。

**1. RESP 发送命令格式**

在`RESP`中，发送的数据类型取决于数据报的第一个字节：

- 单行字符串的第一个字节为`+`。
- 错误消息的第一个字节为`-`。
- 整型数字的第一个字节为`:`。
- 定长字符串的第一个字节为`$`。
- `RESP`数组的第一个字节为`*`。

| 数据类型        | 本文翻译名称 | 基本特征                                                     | 例子                           |
| :-------------- | :----------- | :----------------------------------------------------------- | :----------------------------- |
| `Simple String` | 单行字符串   | 第一个字节是`+`，最后两个字节是`\r\n`，其他字节是字符串内容  | `+OK\r\n`                      |
| `Error`         | 错误消息     | 第一个字节是`-`，最后两个字节是`\r\n`，其他字节是异常消息的文本内容 | `-ERR\r\n`                     |
| `Integer`       | 整型数字     | 第一个字节是`:`，最后两个字节是`\r\n`，其他字节是数字的文本内容 | `:100\r\n`                     |
| `Bulk String`   | 定长字符串   | 第一个字节是`$`，紧接着的字节是`内容字符串长度\r\n`，最后两个字节是`\r\n`，其他字节是字符串内容 | `$4\r\ndoge\r\n`               |
| `Array`         | `RESP`数组   | 第一个字节是`*`，紧接着的字节是`元素个数\r\n`，最后两个字节是`\r\n`，其他字节是各个元素的内容，每个元素可以是任意一种数据类型 | `*2\r\n:100\r\n$4\r\ndoge\r\n` |

发送的命令格式如下，CRLF代表"\r\n":

```
*<参数数量> CRLF
$<参数1的字节数量> CRLF
<参数1> CRLF
...
$<参数N的字节数量> CRLF
<参数N> CRLF
```

以`set hello world`这个命令为例，发送的内容就是这样的：

```
*3
$3
SET
$5
hello
$5
world
```

第一行*3表示有3个参数，3表示接下来的一个参数有3个字节，接下来是参数，3表示接下来的一个参数有3个字节，接下来是参数，5表示下一个参数有5个字节，接下来是参数，$5表示下一个参数有5个字节，接下来是参数。

所以set hello world最终发送给redis服务器的命令是：

```
*3\r\n$3\r\nSET\r\n$5\r\nhello\r\n$5\r\nworld\r\n
```

**2. RESP 响应内容**

```
Redis的返回结果类型分为以下五种：
        正确回复：在RESP中第一个字节为"+"
        错误回复：在RESP中第一个字节为"-"
        整数回复：在RESP中第一个字节为":"
        字符串回复：在RESP中第一个字节为"$"
        多条字符串回复：在RESP中第一个字节为"*"

(+) 表示一个正确的状态信息，具体信息是当前行+后面的字符。
(-)  表示一个错误信息，具体信息是当前行－后面的字符。
(*) 表示消息体总共有多少行，不包括当前行,*后面是具体的行数。
($) 表示下一行数据长度，不包括换行符长度\r\n,$后面则是对应的长度的数据。
(:) 表示返回一个数值，：后面是相应的数字节符。
```

[![img](/img/2021-05-21-Redis-key-乱码/8796093023252288539.jpeg)](https://easyreadfs.nosdn.127.net/5mcTpYIKly3q6SZHnCqjWA==/8796093023252288539)

[![img](/img/2021-05-21-Redis-key-乱码/8796093023252287032.jpeg)](https://easyreadfs.nosdn.127.net/-WZnMntpa2qrVXgy7ds3yA==/8796093023252287032)

