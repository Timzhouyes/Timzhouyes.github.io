---
layout:     post   				    # 使用的布局（不需要改）
title:      《Java特种兵》阅读笔记（2）  		# 标题 
subtitle:    第二章-Java程序员要知道计算机工作原理       #副标题
date:       2020-03-06		# 时间
author:     Haiming 						# 作者
header-img: img/post-bg-2015.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - 编程
    - Java
---

接着学习这本书。

# 第2章 Java 程序员要知道计算机工作原理

## 2.1 Java 程序员需要知道计算机工作原理吗？

这一章主要讲解CPU，内存，磁盘等等角度来看的 计算机的基本原理。也通过缓存来理解优化设计，讲解系统的 I/O 和数据库交互的关系。

## 2.2 CPU的那些事儿

### 2.2.1 从CPU联系到 Java

首先我们清楚，每个进程或者是线程发送操作请求之后，最后会由 cpu 来分配时间片来进行处理。

其处理过程是：

先将操作数传递给 cpu，cpu 计算将其写回“本地变量”之中。这个本地变量通常存在于程序所谓的“栈”之中，如果多次对这些本地变量进行操作，那么CPU会将其cache到cpu的缓存之中。CPU 由寄存器，一级缓存，二级缓存，有的还有三级缓存。

> 一般而言，一级缓存和CPU的延迟在2~3ns 之间，二级缓存通常为 10~15ns,三级缓存在20~30ns，内存在50ns或更高。

在多核的cache 之中，对于某些数据 cache 之后，数据在读取和写入的时候必须满足一些规范，通常叫做“缓存一致性协议”，就像在分布式系统之中我们也要保证数据一致性一样。

知道了上面的这些，那我们接下来就提出问题了：

我们编写的程序如何和CPU交互？是否会被cache住？是否存在并发问题？可能的情况下，如何利用CPU提高程序运行效率？下面就深入底层来了解一下这些过程是如何发生的：

在Java之中，大部分都是申请对象和操作对象，我们都知道对象大部分存在于堆（Heap）之中，那么Java的栈之中存储什么呢？

答案如下：Java 的栈之中更多是 Java 和 OS 一起管理的一块区域，当程序之中的局部变量之中使用基本类型时，其直接在“栈”上申请了一些空间，或者使用引用来引用对象的时候，这些引用的空间也位于“栈”上。

> 确切的说，在编译阶段，Java 就可以决定方法的“本地变量”(LocalVariable)的个数，因此在方法调用的时候，就可以直接分配一个本地变量的区域。
>
> 这个空间是基于 slot 来分配的，每个 slot 占用 32 bit,就算是 boolean也会占用一样的宽度作为一个 slot。当然，long,double 会占用两个 slot。这些 slot 可以被复用，也就是说，在方法体内部，如果某个局部变量时在**循环或者判定语句**内部声明的，那么在退出这个区域之后，其对应的slot可以被释放给在其之后声明的局部变量使用的。

在程序运行的过程之中，是通过 Java 的虚指令来完成对 Java 虚拟机之中的对象和数据做一些操作。虚指令**只是 java 的指令**，而不是最终的指令。**有虚指令才有跨平台**，其最终会在对应OS上面的 JVM被翻译成汇编指令完成对实际硬件的运行操作。

下面是一个常见的例子：

笔者个人记录：

按照书本知识发现javap提示文件不存在，后来发现是要先使用 javac 编译代码，在编译之后才可以使用 javap 来查看代码。自己落了一步而已。

操作步骤应该为:

`javac testClassSum.java   `

`javap -verbose testClassSum`

注意：此处如果文件编码是 GB2312，那么会报错其编码不是 UTF-8，导致文件无法解析（在 javac 就报错）

下面是 console 之中输出的内容：

```java
Warning: Binary file testClassSum contains JavaTeZhongBing.Chapter2.testClassSum
Classfile /Users/zhouhaiming/CodingProjects/AlgorithmStudy/src/main/java/JavaTeZhongBing/Chapter2/testClassSum.class
  Last modified 9 Mar, 2020; size 314 bytes
  MD5 checksum 7f542c6f111cb4ddc530f5b4b34ef487
  Compiled from "testClassSum.java"
public class JavaTeZhongBing.Chapter2.testClassSum
  minor version: 0
  major version: 52
  flags: ACC_PUBLIC, ACC_SUPER
Constant pool:
   #1 = Methodref          #3.#12         // java/lang/Object."<init>":()V
   #2 = Class              #13            // JavaTeZhongBing/Chapter2/testClassSum
   #3 = Class              #14            // java/lang/Object
   #4 = Utf8               <init>
   #5 = Utf8               ()V
   #6 = Utf8               Code
   #7 = Utf8               LineNumberTable
   #8 = Utf8               main
   #9 = Utf8               ([Ljava/lang/String;)V
  #10 = Utf8               SourceFile
  #11 = Utf8               testClassSum.java
  #12 = NameAndType        #4:#5          // "<init>":()V
  #13 = Utf8               JavaTeZhongBing/Chapter2/testClassSum
  #14 = Utf8               java/lang/Object
{
  public JavaTeZhongBing.Chapter2.testClassSum();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object."<init>":()V
         4: return
      LineNumberTable:
        line 3: 0

  public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=4, args_size=1
         0: iconst_1
         1: istore_1
         2: iconst_2
         3: istore_2
         4: iload_1
         5: iload_2
         6: iadd
         7: istore_3
         8: return
      LineNumberTable:
        line 5: 0
        line 6: 2
        line 7: 4
        line 8: 8
}
SourceFile: "testClassSum.java"

```

上面的这部分代码可以分为两部分来看：一部分是常量池描述讯息，一部分是字节码的body 部分。

**下面是第一部分的常量池描述信息的内容：**

常量池描述信息是在编译时就确定的，常量通常包含：类名，方法名，属性名，类型，修饰符，字符串常量，记录其入口位置（符号#上带一个数字，可以理解为一个入口标志位），一些对象的常量值。

常量池只是一些单纯的“列表”，和程序运行没有很大的关系。在实际运行的过程之中需要组合成有效的运行指令，其在 body 内部。

**下面是第二部分的运算指令的内容：**

首先是在书中有一部分内容 LocalVariableTable，其内容在上面的代码之中没有，将其补齐：

![image-20200309153441406](../img/image-20200309153441406.png)

指令不是重点，由于我们是第一次接触，所以对其做部分分析：

- iconst_1，将int类型的值1推送到栈顶。
- istore_1，将栈顶的元素弹出，赋值给第二个 slot 的本地变量。

其综合起来的作用相当于 int a =1;

