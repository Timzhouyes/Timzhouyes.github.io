---
layout:     post   				    # 使用的布局（不需要改）
title:      《Java特种兵》阅读笔记（2）  		# 标题 
subtitle:    第二章-Java程序员要知道计算机工作原理       #副标题
date:       2020-03-06		# 时间
author:     Haiming 						# 作者
header-img: img/post-bg-2015.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - 编程
    - Java
---

接着学习这本书。

# 第2章 Java 程序员要知道计算机工作原理

## 2.1 Java 程序员需要知道计算机工作原理吗？

这一章主要讲解CPU，内存，磁盘等等角度来看的 计算机的基本原理。也通过缓存来理解优化设计，讲解系统的 I/O 和数据库交互的关系。

## 2.2 CPU的那些事儿

### 2.2.1 从CPU联系到 Java

首先我们清楚，每个进程或者是线程发送操作请求之后，最后会由 cpu 来分配时间片来进行处理。

其处理过程是：

先将操作数传递给 cpu，cpu 计算将其写回“本地变量”之中。这个本地变量通常存在于程序所谓的“栈”之中，如果多次对这些本地变量进行操作，那么CPU会将其cache到cpu的缓存之中。CPU 由寄存器，一级缓存，二级缓存，有的还有三级缓存。

> 一般而言，一级缓存和CPU的延迟在2~3ns 之间，二级缓存通常为 10~15ns,三级缓存在20~30ns，内存在50ns或更高。

在多核的cache 之中，对于某些数据 cache 之后，数据在读取和写入的时候必须满足一些规范，通常叫做“缓存一致性协议”，就像在分布式系统之中我们也要保证数据一致性一样。

知道了上面的这些，那我们接下来就提出问题了：

我们编写的程序如何和CPU交互？是否会被cache住？是否存在并发问题？可能的情况下，如何利用CPU提高程序运行效率？下面就深入底层来了解一下这些过程是如何发生的：

在Java之中，大部分都是申请对象和操作对象，我们都知道对象大部分存在于堆（Heap）之中，那么Java的栈之中存储什么呢？

答案如下：Java 的栈之中更多是 Java 和 OS 一起管理的一块区域，当程序之中的局部变量之中使用基本类型时，其直接在“栈”上申请了一些空间，或者使用引用来引用对象的时候，这些引用的空间也位于“栈”上。

> 确切的说，在编译阶段，Java 就可以决定方法的“本地变量”(LocalVariable)的个数，因此在方法调用的时候，就可以直接分配一个本地变量的区域。
>
> 这个空间是基于 slot 来分配的，每个 slot 占用 32 bit,就算是 boolean也会占用一样的宽度作为一个 slot。当然，long,double 会占用两个 slot。这些 slot 可以被复用，也就是说，在方法体内部，如果某个局部变量时在**循环或者判定语句**内部声明的，那么在退出这个区域之后，其对应的slot可以被释放给在其之后声明的局部变量使用的。

在程序运行的过程之中，是通过 Java 的虚指令来完成对 Java 虚拟机之中的对象和数据做一些操作。虚指令**只是 java 的指令**，而不是最终的指令。**有虚指令才有跨平台**，其最终会在对应OS上面的 JVM被翻译成汇编指令完成对实际硬件的运行操作。

下面是一个常见的例子：

笔者个人记录：

按照书本知识发现javap提示文件不存在，后来发现是要先使用 javac 编译代码，在编译之后才可以使用 javap 来查看代码。自己落了一步而已。

操作步骤应该为:

`javac testClassSum.java   `

`javap -verbose testClassSum`

注意：此处如果文件编码是 GB2312，那么会报错其编码不是 UTF-8，导致文件无法解析（在 javac 就报错）

下面是 console 之中输出的内容：

```java
Warning: Binary file testClassSum contains JavaTeZhongBing.Chapter2.testClassSum
Classfile /Users/zhouhaiming/CodingProjects/AlgorithmStudy/src/main/java/JavaTeZhongBing/Chapter2/testClassSum.class
  Last modified 9 Mar, 2020; size 314 bytes
  MD5 checksum 7f542c6f111cb4ddc530f5b4b34ef487
  Compiled from "testClassSum.java"
public class JavaTeZhongBing.Chapter2.testClassSum
  minor version: 0
  major version: 52
  flags: ACC_PUBLIC, ACC_SUPER
Constant pool:
   #1 = Methodref          #3.#12         // java/lang/Object."<init>":()V
   #2 = Class              #13            // JavaTeZhongBing/Chapter2/testClassSum
   #3 = Class              #14            // java/lang/Object
   #4 = Utf8               <init>
   #5 = Utf8               ()V
   #6 = Utf8               Code
   #7 = Utf8               LineNumberTable
   #8 = Utf8               main
   #9 = Utf8               ([Ljava/lang/String;)V
  #10 = Utf8               SourceFile
  #11 = Utf8               testClassSum.java
  #12 = NameAndType        #4:#5          // "<init>":()V
  #13 = Utf8               JavaTeZhongBing/Chapter2/testClassSum
  #14 = Utf8               java/lang/Object
{
  public JavaTeZhongBing.Chapter2.testClassSum();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object."<init>":()V
         4: return
      LineNumberTable:
        line 3: 0

  public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=4, args_size=1
         0: iconst_1
         1: istore_1
         2: iconst_2
         3: istore_2
         4: iload_1
         5: iload_2
         6: iadd
         7: istore_3
         8: return
      LineNumberTable:
        line 5: 0
        line 6: 2
        line 7: 4
        line 8: 8
}
SourceFile: "testClassSum.java"

```

上面的这部分代码可以分为两部分来看：一部分是常量池描述讯息，一部分是字节码的body 部分。

**下面是第一部分的常量池描述信息的内容：**

常量池描述信息是在编译时就确定的，常量通常包含：类名，方法名，属性名，类型，修饰符，字符串常量，记录其入口位置（符号#上带一个数字，可以理解为一个入口标志位），一些对象的常量值。

常量池只是一些单纯的“列表”，和程序运行没有很大的关系。在实际运行的过程之中需要组合成有效的运行指令，其在 body 内部。

**下面是第二部分的运算指令的内容：**

首先是在书中有一部分内容 LocalVariableTable，其内容在上面的代码之中没有，将其补齐：

![image-20200309153441406](../img/image-20200309153441406.png)

指令不是重点，由于我们是第一次接触，所以对其做部分分析：

- iconst_1，将int类型的值1推送到栈顶。
- istore_1，将栈顶的元素弹出，赋值给第二个 slot 的本地变量。

其综合起来的作用相当于 int a =1;

**iconst相关的命令包括：**

Iconst_m1,iconst_[0-5],对应虚指令的范围有[0x03~0x08]，表示[-1~5]之间的数字常量加载到栈顶，如果不是这个范围的数字，就 bipush 指令。

 istore_1 是赋值给 slot 为起始位置的本地变量，istore_0 才是赋值给第一个 slot 起始位置，那么第0个本地变量是什么呢？是 **main 方法传入的string[] 参数**。同样的，如果是非静态方法，**this 将作为任何方法的第一个本地变量**。

在图中我们也看出来了，几个变量所对应的 slot 编号也输出了，这里面的每个局部变量都单独占用一个 slot,如果局部变量之中有 double,long 等类型，slot 的个数就会变多。

LocalVariableTable列表是本地的列表，某些开发工具默认有这些信息，通过 javac 编译之后的 class 文件默认是没有这些输出信息的。也就是**默认情况下本地变量没有名称的概念**。

LocalVariableTable 列表之中每一行都代表一个本地变量，每一列的解释如下：

- Start， 代表本地变量在虚指令作用于之中的起始位置，比如第一个本地变量args 是从 0 开始的。
- Length，代表本地变量在虚指令列表之中的作用域长度，比如第一个本地变量 args 是 9条指令的作用域。
- Slot，代表本地变量的 slot 的起始位置编号，此处为顺序排布，但是如果出现 long，double 等等就会跳跃。原因上面讲了，是因为一个long占用为2个 slot。
- Name，代表本地变量的名称，也就是本地定义的名称。

- Signature，代表本地变量的类型，比如第一个是 String 类型，其他几个都是 Int 类型。

接下来，同样是将int类型的值2推到栈顶并且保存在第三个 slot 的本地变量之中。

 iload_1 和 iload_2 是将两个本地变量的值推至栈顶，然后指定一个iadd 操作计算出叠加之后的结果放在栈顶，istore_3 将结果数据从栈顶 pop 出来，保存在第4个slot所对应的本地变量之中。

> 这里的“栈顶”是一个后进先出的 Stack，可以具体由和CPU 交互的操作数组成，但是其并不等价于本地变量。其可以进行多个操作之后，写回到指定的本地变量之中。或者只是用于读操作，就不需要写回本地变量之中了。

这些指令是 JVM 的虚指令，其可能将某些原来代码的顺序重排，虚指令在翻译成CPU的指令阶段也可能重排序。

本节，我们只需要知道 JVM 能发出指令请求，由 OS 来完成具体工作，JVM 自己本身无法完成计算工作就OK。

### 2.2.2 多核

多核要发挥最大作用，问题是不要让部分CPU闲置。请求的负载均衡部分就包括：

- 指令由哪个CPU处理？
- 同一个数据被多个CPU处理，并且对其进行修改之后，如何让其他CPU知道？

上面这些都是负载均衡的部分。

当发起一个计算请求的时候，例如一个中断，这么多的CPU会干什么呢？这就得从任务的模型开始说起。

- 一开始，操作系统可能是不断的扫描各个部件查看是否有指令来，有的话就及时处理。但是这种模式往往会有延时，因为”知道的时候都晚了“

- 后来，CPU有了中断模型，通过中断来完成调用。但是某些行为的中断频率过高（比如鼠标移动，不断发送指令）。那么优化方案就是对中断做一个缓冲区，由于CPU的处理速度很快，可以在瞬间处理大批量的请求，所以缓冲区会很快被清空。
- 一系列任务可能要做各种各样事情，通常情况下CPU的计算速度很快，但是 OS 不希望CPU因为一个”等待指令“或者长期执行的任务使得自己”陷入困境“。比如一些 I/O 等待，其中途基本都不参与，而是以事件注册的方式来实现回调。而对于某些执行时间长的任务，CPU可能会分配一些时间片来处理其他的任务。

当多个CPU在同一台计算机之中出现的时候，会出现什么情况呢？有以下几种情况：

1. ”大家一起抢指令“这个是不多见的。只有在某些系统之中有多进程模式，多个进程去监听一个段口，在其得到信号时，可能多个进程同时被唤醒。这种模式叫做”惊群“
2. 有一个CPU来分配指令，这种方式也存在。虽然在这个情况下很可能此CPU的占用率过高，但是其至少实现了调度，且可以实现一定程度的”资源隔离“。
3. 按照板块来划分，且每个板块之中有专门的CPU来管理调度区域，也未必合理。首先，数据还需要和其他部分的部件通信，很难实现完全的隔离。其次，板块划分完之后，很可能出现热点问题，某个或者某几个板块过热。

所以并不存在”完美“的方案，要针对程序所处情景和方式进行具体的分配。

### 2.2.3 Cache line

cache line，从名字上面猜测意义为”cache行“。那么什么叫做一行？为啥要cache 一行？一行有多长？这些又和我编写 Java 程序有什么关系呢？

Cache line 将”连续的一段内存区域“ 进行 Cache，而不是每次就 Cache 一个内存单元。通常在计算机之中以64字节作为一个基本单位进行Cache 操作。

这样在操作相关的数据时，就不需要每次都从内存之中读取了。下面举一个二位数组的例子来说明其效率的差异。

遍历二维数组` int [][]a = new int[5][10]`

要遍历这个二维数组，通常用二层循环来遍历，分别遍历两个维度，有两个方法，一种是外层循环第一维，内层循环第二维。另一种是相反的顺序。

这两种顺序哪个效率高呢？

效率高的是第一种。因为在 Java 数组在内存分配之中是先分配第一维，然后再分配多个第二维子数组。也就是说`a[0][x]` 和 `a[1][x]` 是两个数组上面的，其空间也自然不在一起。

单个数组的内存空间是连续的，那么当获取 `a[0][0]` 时，Cache Line会将所有的相关元素，例如`a[0][1]`等等都Cache到CPU的缓存之中，当使用第一种遍历方式来遍历的时候，这些数据只需要Cache一次就可以完成，但是第二种方式下标访问即为不连续的，那么就没法一次Cache，要多次重新访问内存才行。

**问：** 如果CPU Cache时时按照连续内存空间进行的，那么对内存进行了修改，回写的时候是不是也是按照行进行的呢？

**答：**不是，Cache line 的目的是为了快速访问，其对内存单元做出的修改有明确的定义，在回写的时候，也会找到对应的内存空间。

### 2.2.4 缓存一致性协议

上面讲了 cache line,以及CPU的 cache 作用。下面了解一下缓存一致性协议：

当有来自内存的同一份数据 cache 在多个CPU之中，且要求这些数据的读写一致时，多个CPU之间就得遵循缓存共享的一致性原则。

那这个该如何理解呢：可以理解为很多人都拿到了一份设计报告的模板作为初稿，每个人都拿回去进行修改，但是要求是**任何人做出的修改都要让别人知道你对哪些内容做了什么修改**，以便于大家可以在你修改的基础上做出进一步的修改。这也就是我们说的一致性。如图所示：

![image-20200310143728999](/img/image-20200310143728999.png)

这种模型之中，在CPU上面的实现就对应于多个CPU针对同一个内存单元都有自己的一份拷贝，当某个CPU修改其共享数据时，需要通知其他的CPU数据已经修改。

内存单元有以下几种状态：

- 修改（Modified）
- 独占（Exclusive）
- 共享（Shared）
- 失效（Invalid）

等等。多个CPU之间通过总线相连。那么每个CPU的Cache处理器除了要相应本身的对应的CPU的读写操作之外，还需要监听总线上面的其他CPU的读写操作，通过这些操作对自己的Cache做相应的处理，形成了一种虚共享，这个叫做MESI协议。

一个数据修改了，需要告诉其他的CPU数据被修改，现代CPU的Intel微架构是使用QPI完成的。但是CPU的交互是有一个时间差的，通常在20~40ns 级别，频繁的交互会使系统性能下降，而且CPU的使用量会飙高。就像一个公司的人过多，那么很多时候都要开会，大家都在忙，但是没做多少事情。

**会有怎么样的一种场景呢？**

比如设计一个数组来表示一组状态，数组之中多个下标分别表示一种”状态“，每个线程之中独自享有自己的状态，这个设计表面上好像已经脱离了锁，让他更具有性能扩展性。但是并不是这样，举个例子 ：

定义一个拥有 volatile 变量的对象数组：

```java
class VolatileInteger {
	volatile int number;
}

final VolatileInteger[]values = new VolatileInteger[10];
		for(int i = 0 ; i < 10 ; i++) {
			values[i] = new VolatileInteger();
		}
```

那么如果此时有多个CPU使用这个数组的元素，即使每个线程只是操作对应的某个指定的数组下标，那么数组之中的多个元素由于Cache line也可能会被不同的CPU cache 到，每个CPU可能只修改某个元素，依旧会有大量的交互存在，导致其出现大量的QPI现象。

**疑问：**

Java 的数组对象之中，数组中仅仅包含引用，对象应当有单独的空间。那么不包含内容的怎么会有连续的空间呢？

**解答：**

Java 的堆内存在分配时，会相对较为连续的分配，这样在某些问题的处理上比较方便（书中并没有讲是哪部分），上面的代码是使用for循环来分配空间的， 那么分配过程很快，没有并发的情况下其是比较连续的。如果发生了GC，那么在同一个对象的引用合并之后，其内存空间也会相对的较为连续，所以Cache line的概率是很高的。

### 2.2.5 上下文切换

”上下文切换“，(context switch) 之中的”上下文“，也就是内容，简单来说就是内容切换。

**问题：**为何有内容切换？何时进行内容切换？切换的内容是什么？Java 系统如何做这些事情？

**回答：**举个例子。比如出门办事有10个步骤，办到一半的时候其发现需要暂时登一下，那么在其等待的时间之内，办理材料的人肯定是要先去给别人办理，当其回来的时候，可能办理材料的是另一个人，不管是谁都得重新看这些材料，从还没完成的步骤向下办理。

那么在计算机之中也是一样。

线程已经执行了一部分内容，需要记录下其内容和状态，中间由于调度算法（比如分时间片，调用让步和休眠等等）或者阻塞等原因，导致还没完全结束的线程离开CPU的调度，此时需要保留现场，以便重新调用的时候可以找到其上次执行的位置。比如在I/O 方面，一次普通的API调用，一次数据库访问，一次磁盘请求，此时线程会陷入 Blocking 状态，以至于发生所谓的”上下文切换“。

大部分知识会提及进程比线程具有更高的开销，进程独立向OS申请资源，而线程是共享进程的资源。下面仔细剖析一下：

目前CPU调度的最基本单位是**线程**，Java 也是基于多线程模式的，而非多进程模式。由于资源共享，在Java 之中的一个线程如果过大，将一个 JVM 进程直挂死掉，这种情况在多进程模式之中不会发生。

通常在实际运行之中会有代码段和数据段，内容切换的时候就得保存这些上下文信息，需要使用的时候再加载回来，以便知道在哪个位置继续执行，以及执行之中的本地信息。

类似于 log4j 这种开源的日志工具使用的就是异步模式来实现日志的写操作，而程序通常不直接参与这个操作，那么大部分线程就可以直接完成处理。其实现方式是，日志的写操作会直接写入一个消息队列之中，再由单独的线程来完成写操作。

### 2.2.6 并发和征用

