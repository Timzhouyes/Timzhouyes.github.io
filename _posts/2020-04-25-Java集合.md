---
layout:     post   				    # 使用的布局（不需要改）
title:      Java集合初探  		# 标题 
subtitle:           #副标题
date:       2020-04-25		# 时间
author:     Haiming 						# 作者
header-img: img/post-bg-2015.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - Programming
    - Java
    - Collection
---

还是天问五连：是什么？有什么特点？怎么用？如何实现？有什么要注意的地方？

走！

# 1. Collection

## 2.1 什么是Collection

Java是一门面向对象的语言，那么有的时候我们需要对不止一个对象进行处理，这种情况就需要”集合“，也就是Collection来存放对象。

## 2.2 怎么用？

![image-20200426152818181](../img/image-20200426152818181.png)

可以看出很多方法，比如 size()，contains()，iterator() ,add(),remove() 等等，都是Collection提供的。

![image-20200426153402062](../img/image-20200426153402062.png)

### 2.2.1 retainAll()

最后这个retainAll()平时用的很少，下面是代码示例：

```java
package UseToStudyJavaClass.CollectionStudy;

import java.util.ArrayList;

public class RetainAllTest {
    public static void main(String[] args) {
        ArrayList<Integer> arr1 = new ArrayList<>();
        arr1.add(1);
        arr1.add(2);
        arr1.add(3);

        ArrayList<Integer> arr2 = new ArrayList<>();
        arr2.add(1);
        arr2.add(4);
        arr2.add(5);

        boolean status =arr1.retainAll(arr2);
        System.out.println("Status is "+status);
        for(int i:arr1){
            System.out.println(i);
        }

    }
}

```

结果是：

```java
Status is true
1
```

### 2.2.2 迭代器(iterator)

```java
public interface Collection<E> extends Iterable<E> {
```

基础功能有：

1. size()

   

Collection本身就继承了Iterable这个接口。

```java
public interface Iterable<T> {
    /**
     * Returns an iterator over elements of type {@code T}.
     *
     * @return an Iterator.
     */
    Iterator<T> iterator();
```

而Iterable这个接口之中有一个Iterator,其本身还是一个接口：

![image-20200426154131032](../img/image-20200426154131032.png)

其中第一个方法：

```java
/**
     * Performs the given action for each remaining element until all elements
     * have been processed or the action throws an exception.  Actions are
     * performed in the order of iteration, if that order is specified.
     * Exceptions thrown by the action are relayed to the caller.
     *
     * @implSpec
     * <p>The default implementation behaves as if:
     * <pre>{@code
     *     while (hasNext())
     *         action.accept(next());
     * }</pre>
     *
     * @param action The action to be performed for each element
     * @throws NullPointerException if the specified action is null
     * @since 1.8
     */
    default void forEachRemaining(Consumer<? super E> action) {
        Objects.requireNonNull(action);
        while (hasNext())
            action.accept(next());
    }
```

意思就是把每个元素都过一遍这个叫做action 的 Consumer,，直到过完或者抛出异常。

下面的三个方法我们都无比熟悉了。
按照博主的意思，其是在ArrayList之中的内部类被实现的：看到这个Itr()了没。

![image-20200426154821356](../img/image-20200426154821356.png)

那么这个迭代器怎么用呢？

```java
package UseToStudyJavaClass.CollectionStudy;

import java.util.ArrayList;
import java.util.Iterator;

public class IterableTest {
    public static void main(String[] args) {
        ArrayList<Integer> arr1 = new ArrayList<>();
        arr1.add(1);
        arr1.add(2);
        arr1.add(3);
        
        Iterator i = arr1.iterator();
        while(i.hasNext()){
            System.out.println(i.next());
        }
    }
}
```

由于每个继承了Collection的对象都有iterator(),其返回的就是一个 Iterator，那么就可以按照iterator的三个方法来对ArrayList做操作。

## 2. 有什么要注意

数组和集合的区别：

1. 数组的长度固定，集合的长度可变
2. 数组可以存储基本类型和引用类型(int[] 或者 Integer[])都可以，但是集合只能存储**引用类型**，如果存储的是基本类型，会进行自动装箱操作——从int变成Integer

迭代器为什么不设计成一个类，而是一个接口？

如果设计成一个类，有两种：抽象类和实体类。

如果设计成抽象类，按照java的不可多重继承原则，其就没法去继承其他的类。那么就会出现使用上面的短板。如果写成实体类，即其可以直接实体化成一个对象，那么对于不同种类的Collection，其遍历方法必然不同，也就没法产生这样一个随处可用的实体方法。所以其只能是一个接口。

## 2.3 List简介

Collection之中主要分两种：Set和List。一个无序不重复，一个有序可重复。

### 2.3.1 是什么？有什么特点？

是一个有序可重复的implement Collection接口的接口

### 2.3.2 怎么用？

### 2.3.3 如何实现？

其中对Collection 的 Iterator进行了自己的实现。

![image-20200426160453874](../img/image-20200426160453874.png)

可见主要是多了往前遍历，添加元素和修改元素的操作。

#### 2.3.3.1 常用子类

1. ArrayList: 底层数据结构是数组，线程不安全
2. LinkedList: 底层数据结构是链表，线程不安全
3. Vector: 底层数据结构是数组。线程安全。

## 2.4 Set简介

### 2.4.1 是什么？

是一个不可重复的Collection实现

### 2.4.2 常用子类

1. HashSet: 底层是HashTable
2. TreeSet: 底层红黑树，元素有大小的排序
3. LinkedHashSet: 底层是HashTable+ LinkedList

## 2. List集合精讲

主要讲这三个子类的特别用法和实现：

1. ArrayList: 底层数据结构是数组，线程不安全
2. LinkedList: 底层数据结构是链表，线程不安全
3. Vector: 底层数据结构是数组。线程安全。

## 2.1 List是什么？有什么特点？（略，之前讲过）

## 2.2 ArrayList

### 2.2.1 ArrayList 如何实现？

底层就是一个数组，第一次添加元素到ArrayList 之中的时候，数组将扩容DEFAULT_CAPACITY（默认是10）。

![image-20200426161313469](../img/image-20200426161313469.png)

```java
    /**
     * Constructs an empty list with the specified initial capacity.
     *
     * @param  initialCapacity  the initial capacity of the list
     * @throws IllegalArgumentException if the specified initial capacity
     *         is negative
     */
    public ArrayList(int initialCapacity) {
        if (initialCapacity > 0) {
            this.elementData = new Object[initialCapacity];
        } else if (initialCapacity == 0) {
            this.elementData = EMPTY_ELEMENTDATA;
        } else {
            throw new IllegalArgumentException("Illegal Capacity: "+
                                               initialCapacity);
        }
    }
```

#### 2.2.1.2 add(E e) 如何实现？

1. 检查是否需要扩容:
   - 足够：直接添加
   - 不足够：扩容，在原来容量的1.5倍和minCapacity(默认长度和要扩容的长度之中的最大值）之中取最大值。
2. 插入元素

```java
public boolean add(E e) {
    ensureCapacityInternal(size + 1); // Increments modCount!! 									elementData[size++] = e;
	return true;
}
```

#### 2.2.1.3 add(int index, E element)如何实现？

1. 检查角标是否越界
2. 空间检查是否需要扩容
3. 插入元素：使用arrayCopy(),其是一个native方法

#### 2.2.1.4 get(int i) 如何实现？

1. 检查角标
2. 返回具体元素

#### 2.2.1.5 E set(int index, E element) 如何实现？

1. 检查角标是否越界
2. 替代元素
3. 返回旧值

#### 2.2.1.6 E remove(int index) 如何实现？

1. 检查角标是否越界
2. 计算后面部分需要向左移动的个数
3. 将最后一个元素设置为null，从而让GC回收

![image-20200426162813552](../img/image-20200426162813552.png)

### 2.2.2 ArrayList有什么坑？

其在删除数据的时候不会减少容量。想要减少需要自己调用trimToSize():

```java
/**
 * Trims the capacity of this <tt>ArrayList</tt> instance to be the
 * list's current size.  An application can use this operation to minimize
 * the storage of an <tt>ArrayList</tt> instance.
 */
public void trimToSize() {
    modCount++;
    if (size < elementData.length) {
        elementData = (size == 0)
          ? EMPTY_ELEMENTDATA
          : Arrays.copyOf(elementData, size);
    }
}
```

ArrayList 可以存放null值。

```java
package UseToStudyJavaClass.CollectionStudy;

import java.util.ArrayList;
import java.util.Iterator;

public class ListTest {
    public static void main(String[] args) {
        ArrayList<Integer> arr = new ArrayList<>();
        arr.add(1);
        arr.add(2);
        arr.add(null);
        arr.add(3);
        Iterator i = arr.iterator();
        while(i.hasNext()){
            System.out.println(i.next());
        }
    }

}
```

输出为：

```java
1
2
null
3
```

### 2.2.3 Vector和ArrayList的区别

Vector底层也是数组，但是其线程安全。使用的方法就是全部Synchronized 一遍方法。

### 2.3 LinkedList 怎么用？

LinkedList是一个双向链表。

![image-20200426163601754](../img/image-20200426163601754.png)

其还实现了Deque接口，deque全称是双端队列(double-ended queue)，其具有队列和栈的性质，元素可以从两端弹出。

![image-20200426163851129](../img/image-20200426163851129.png)

双端的操作都在这个接口里面，从First和Last做操作全在其中。

### 2.3.1 构造方法

![image-20200426170053501](../img/image-20200426170053501.png)

要么无参构造，要么将另一个Collection的东西加入LinkedList。

### 2.3.2 remove(Object o)

删除时候看 equals() 是否成立，成立的话就unlink这个节点。

unlink 原理：

![image-20200426170343993](../img/image-20200426170343993.png)

### 2.3.3 get(int index)方法

其也是遍历，但是看下标。下标小于长度一半，就从头遍历。不然就从尾遍历。

![image-20200426170541112](../img/image-20200426170541112.png)

### 2.3.4 E set(int index, E element)

也是先看index决定从头还是尾遍历，找到对应的Node之后就替换值，并且将**旧值返回**。

# 3. Map详解

## 3.1 什么是 Map？Map的特点？

之前讲过Java之中的数据结构主要分Map和Collection。Map就是映射对。

## 3.2 Map怎么用？

![image-20200426171246146](../img/image-20200426171246146.png)

## 3.3 什么是红黑树？为什么要有红黑树？

一开始我们是有BST的。但是BST在最坏的情况下会退化成一个链表。那么就出现了平衡树的概念——红黑树就是一种平衡树（左右子树的高度相差不超过1）。

那么为了保证平衡，多了一种”2-3树“：

![image-20200426172030284](../img/image-20200426172030284.png)

2-3树在插入的时候要涉及到很多节点的合并和分解，不太行。有啥办法能避免这一步呢？

红黑树闪亮登场！

红黑树用旋转和变色来替代节点的合并分解操作，比2-3树的维护要方便一些。

# 4. HashMap

## 4.1 是什么？

是一个用hash进行散列的key-value的map。

## 4.2 怎么实现？

基本属性：

1. 初始容量16
2. 最大容量：2的31次方
3. 默认Load_factor = 0.75
4. TREEIFY_THRESHOLD = 8, 一个桶之中的节点数目超过这个那么就变树
5. UNTREEIFY_THRESHOLD = 6，一个桶之中节点数目小于这个就变成链表
6. MIN_TREEIFY_CAPACITY = 64，小于这个数量的桶的话不会变成树。

其内部的实现就是数组+链表。

HashMap: 

1. 无序，允许key为null
2. 底层是数组+链表实现
3. 初始容量和load_factor对其影响都是蛮大的，当然也可以将load_factor设置成2，那么永远不会扩容了。

### 4.2.1 构造方法

可传入Capacity和loadFactor来进行构造。其中capacity会有一个方法`tableSizeFor()`来生成，其返回值是一个大于输入参数且最近的2的整数次幂。

### 4.2.2 put() 方法

最重要的部分是得到hashCode。

![image-20200426174925568](../img/image-20200426174925568.png)

为什么对于key的hashcode还要再将其和hashCode的高16位做异或运算？

hashmap的初始容量为16，那么我们想要将数据放在的位置是就是0~15，也就是 (n-1) 是其极限值。那么按照下图：

![image-20200426175158436](../img/image-20200426175158436.png)

可以看到就是`(n-1) & hash`这个位运算再起作用。那么当n比较小，比如16这个初始容量的时候，其只有低位会参与其中。那么如何让高位的hash值也起作用呢？就是上面这一句“再将其和hashCode的高16位做异或运算”。这就增加了随机性。