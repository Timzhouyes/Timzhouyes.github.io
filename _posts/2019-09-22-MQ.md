---
layout:     post   				    # 使用的布局（不需要改）
title:     对MQ的一些梳理				# 标题 
subtitle:   总结一个MQ的GitChat #副标题
date:       2019-09-22 				# 时间
author:     Haiming 						# 作者
header-img: img/post-bg-2015.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - 编程
    - MQ


---

在看了一个[GitChat](https://gitbook.cn/books/5d65124b2b27dd24ed390665/index.html)之后，在自己的blog里面做一下notes和写一下自己的想法。

推荐”石杉的架构笔记“，也是这篇文章的出处。

# 1. 概述

消息中间件（Message Queue,简称 MQ）是我们平时经常用到的一个东西，但是对于业务而言，可能我们平时更多的是在于会实现生产信息，消费信息。但是深入思考之后可能发现下面的几个问题我们从未认真思考过：

- 为何要使用MQ
- 使用了MQ之后有什么缺点？
- 怎么保证MQ消息不丢失？
- 怎么保证MQ的高可用性？

那么下面就做一些总结。

# 2. 为什么要用MQ？

MQ 的核心场景有三个：

1. 异步
2. 解耦
3. 削峰填谷

## 2.1 异步

异步主要是针对这种情况：调用不同系统接口所需要的时间长度不同，那么如果等待不同接口全部返回确认的消息再对用户进行返回的事件过长用户无法接受哦。

例如下面这个例子：

假设 A 系统接收一个请求，需要在自己本地写库执行 SQL，接着需要调用 BCD 三个系统的接口。自己本地写库要 3ms，调用 BCD 三个系统分别要 300ms、450ms、200ms。最终请求总延时是 3 + 300 + 450 + 200 = 953ms，接近 1s，可能用户会感觉太慢了。

![img](../img1/5cff7855e4b0a64c88b00d73.png)

但是当使用MQ 之后，系统 A 只要发送三条消息到 MQ 的三个消息队列，然后就返回给用户了。这样的话所有耗时就是发送到 MQ 的耗时，再加上发送给用户的耗时。假设发送消息到 MQ 中耗时 20ms，那么用户感知到这个接口的耗时仅仅是 20 + 3 = 23ms，用户几乎无感知。

![img](../img1/5cff7990e4b071ad5a1fb10b.png)

可以看到在这种情况下，系统会将整个系统需要执行的部分在后端利用消息队列进行通知，而对客户只要返回结果就好。那么会大大提高接口的性能。

## 2.2 解耦

假设 A 系统在用户发生某个操作的时候，需要把用户提交的数据同时推送到 B，C两个系统，如果通过 Http 或者 RPC 接口进行操作的时候，会是下面的这种模式：

![img](../img1/5d021acce4b08ceab31a5c30.png)

这种模式的确简单美好，但是业务如果发生迭代，多了几个系统也要这个数据，我们拿D，E，F举例，那么就需要修改源代码，将数据也传给其他几个系统。

这种纯粹增加系统的场景还好，如果有多种操作，例如还有其他数据要发送给某几个系统C，D，E，或者某些场景D又不需要这个数据了，那么应对多种系统之间的业务调整会让开发人员陷入一种非常被动的境地。

而且上面提及的这些部分也只是说增加或者减少系统的情况，如果还有其他要求，例如重试，超时等等情况，那么代码的复杂程度会急剧增加，对整个开发过程极其不利。

![img](../img1/5d021c5ce4b0591fc0e0871c.png)

这种情况下，非常适合利用 MQ 来进行解耦，这样负责 A 系统的开发者只需要将消息传到 MQ 之中，其他系统来订阅消息就好。就算某个系统不需要，或者某个系统突然需要这个数据，也不需要A 系统来改动任何代码。

![img](../img1/5d021e1fe4b0a65d80993364.png)

## 2.3 削峰填谷

比如某些订单系统，下单的时候会向数据库之中写入数据，但是数据库只能支持一定量，比如 每秒1000次 左右的并发写入，并发量再高就会死机。但是数据总是有高峰和低谷的情况出现，可能平时的写入量只有 每秒100次 左右，但是高峰期是 每秒5000次。那么数据库会直接 down 掉，一点挣扎都不会有的，就像这样：

![img](../img1/5d022063e4b071ad5a22f894.png)

但是如果使用了 MQ 之后，消息可以被 MQ 保存起来，那么系统可以按照自己的能力来进行消费，比如 每秒1000个 数据，这样慢慢写入数据库，就不会一下子将数据库打死了：

![img](../img1/5d02265ae4b0a64c88b356ce.png)

削峰填谷的由来请看下图：

![img](../img1/5d022708e4b08ceab31a71c8.png)

像我们之前提到过的，业务量总有高峰和低谷，那么在高峰的时候系统容量不够，在低谷的时候系统性能又没有被完全利用。没有使用 MQ 的情况之下，并发量高峰期是有一个顶峰的，在高峰期过后又是一个低并发的谷。

但是使用了 MQ 之后，限制消费信息的速度为 1000， 这样一来，高峰期产生的数据

