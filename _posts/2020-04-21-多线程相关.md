---
layout:     post   				    # 使用的布局（不需要改）
title:      多线程相关总结  		# 标题 
subtitle:   包括多线程，线程池等等        #副标题
date:       2020-04-21		# 时间
author:     Haiming 						# 作者
header-img: img/post-bg-2015.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - Programming
    - MultiThread
---

参考资料：Java3y的文章。

# 1. 为什么要使用多线程？

首先，目前的CPU一般都是多核的，如果在多核CPU上同一时刻只跑一个线程，那未免太浪费了。另外，对于IO密集型操作，CPU等待IO的时间比较长，这段时间其实也是浪费掉了的。那么多线程就可以有效的利用多核或者IO的等待时间。

# 2. 多线程有哪些地方需要注意？

多线程的花活玩法比如**线程池**，在数据库连接的过程之中我们就使用了线程池+ThreadLocal。线程池之中始终有活跃的连接线程，ThreadLocal之中保存线程，那么就可以保证对于当前线程而言，每一次拿到的连接都是同一个。

线程池之中始终保持多个活跃的连接线程，意义是在多线程访问的时候可以提供不止一条连接，同时防止频繁的建立和断开连接的操作。省去了每次的三次握手四次挥手等等。

> 使用线程池的时候，往往我们的调用方都不需要考虑**请求是否立马处理成功**。假设线程池在处理任务的时候因为某些原因失败了，我们可以走**报警**机制（用邮件/短信等渠道去提醒请求方即可）。
>
> 不知道大家学过消息队列了没有，我们常常说消息队列是**异步**的，很多时候调用方的请求我们丢到消息队列里边，就告诉调用方我们这条请求处理成功了。实际上，这个请求可能还交由下游的多个系统去处理，下游的系统可能也是异步的…..
>
> 在使用线程池的时候，很多时候我们也是把他当做异步来使，只要我们的系统之间交互不是强一致性的，又希望提高系统的吞吐量，我们就可以考虑使用线程池。

上面这段引用之中就说明了，想要提高吞吐量，又不在意强一致性，不需要同步的情况下，就可以使用线程池。

# 3. ThreadLocal

## 3.1 什么是ThreadLocal？

我们都知道JVM之中，线程共享进程的很多东西，实际上自己独立的部分除去JVM栈，本地方法栈和程序计数器之外啥都没有，可怜的一批。那么如果在某些情况，比如上文说到的这种数据库连接的情况下想维持自己的一个connection，那么就得使用ThreadLocal。ThreadLocal是属于每个线程的一个副本，其不受其他线程所影响。

> ThreadLocal提供了线程的局部变量，每个线程都可以通过`set()`和`get()`来对这个局部变量进行操作，但不会和其他线程的局部变量进行冲突，**实现了线程的数据隔离**～。

## 3.2 ThreadLocal的一些好处？

比如上文之中讲的其在线程内部保存一些变量，对每个线程而言数据库的连接是唯一且稳定的之外，还有避免参数传递的作用：其只是每个Thread内部具有的值，那么传递参数的时候就不需要再去选择Thread，而是直接在当前的Thread之中拿取就好了。

## 3.3 ThreadLocal的实现原理

Talk is cheap, show me the code:

首先看ThreadLocal 的 set 方法：

```java
public void set(T value) {
        Thread t = Thread.currentThread();
        ThreadLocalMap map = getMap(t);
        if (map != null)
            map.set(this, value);
        else
            createMap(t, value);
    }
```

看到这边有个ThreadLocalMap，点进去看下：

```java
static class ThreadLocalMap {

        /**
         * The entries in this hash map extend WeakReference, using
         * its main ref field as the key (which is always a
         * ThreadLocal object).  Note that null keys (i.e. entry.get()
         * == null) mean that the key is no longer referenced, so the
         * entry can be expunged from table.  Such entries are referred to
         * as "stale entries" in the code that follows.
         */
        static class Entry extends WeakReference<ThreadLocal<?>> {
            /** The value associated with this ThreadLocal. */
            Object value;

            Entry(ThreadLocal<?> k, Object v) {
                super(k);
                value = v;
            }
        }
  //下面是维护相关的部分，和主题关系不大，省略~
```

可以看到ThreadLocal是Thread的一个内部类，其中存放的是Entry，一个以ThreadLocal为key，以Object为value的一个对。这个thread有啥关系？再看！

```java
ThreadLocalMap getMap(Thread t) {
        return t.threadLocals;
    }
```

上面这个getMap方法之中，返回的是Thread的threadLocals。那这又是啥？

```java
   /* ThreadLocal values pertaining to this thread. This map is maintained
     * by the ThreadLocal class. */
    ThreadLocal.ThreadLocalMap threadLocals = null;
```

原来返回的部分就是ThreadLocal之中的 ThreadLocalMap。

那么再看上面的 set 方法就很清晰了。

在Thread类之中，有一个

```java
    /* ThreadLocal values pertaining to this thread. This map is maintained
     * by the ThreadLocal class. */
    ThreadLocal.ThreadLocalMap threadLocals = null;
```

注意，是在Thread里面哈。

那么每一个Thread都有一个ThreadMap，首先通过 getMap(t) 来拿到当前Thread t的一个ThreadMap，如果其不是null，那么说明已经创建好了，就用当前的ThreadLocal当做key，以要存放的Object当做Value来存放在这个map里面。不然就初始化这个ThreadLocalMap并且将值放入其中。

> **ThreadLocal本身并不存储值**，它只是**作为一个key来让线程从ThreadLocalMap获取value**。

那么这样就可以做到线程之间的隔离，因为ThreadLocalMap就是对于每个线程独有的，怎么可能会让别的线程看到其中的值呢？

## 3.4 ThreadLocal的内存泄露

ThreadLocal的内存泄露原因是，**ThreadLocal的生命周期和Thread一样长**，如果没有手动去remove() 对应的key，那么其就会一直存在，久而久之就会内存泄露。

# 4. 多线程

## 4.1 为什么要有线程？

我们都知道，在计算机领域，一个程序就是一个进程，可以独立执行。那么为什么还要线程呢？是因为进程的切换之中过于重量级，那么引入线程作为调度的最小单位，就可以减少调度切换的时间，使OS具有更好的并发性。

## 4.2 线程的基本属性和类型

线程的基本属性有：

1. 独立调度和分配的基本单位
2. 可并发执行
3. 共享进程的资源

类型：

1. 用户级线程：用户自行管理，OS只对进程负责
2. 系统级线程：由OS内核**管理**，OS内核给程序提供相应的系统调用和API，让用户可以创建，执行和撤销线程。注意，此处没有“管理”。

## 4.3 多线程的意义

多线程实际是为了提高程序的使用率，比如在IO密集型的程序之中提高吞吐量。即使线程的切换比进程的切换要省很多资源，但是也还是需要一定的资源，并且CPU同时也只能执行一个线程。

> 引入线程主要是**为了提高系统的执行效率，减少处理机的空转时间和调度切换的时间，以及便于系统管理。**使OS具有更好的并发性

此处处理机的空转时间指的就是阻塞的时间，而调度的时间就是切换进程所需要的时间。

## 4.4 多线程的实现方式

有两种：

1. 继承 Thread，重写 run() 方法
2. 实现 Runnable 接口，重写 run() 方法，然后将自己写的Runnable接口传递到Thread之中。

**第一种：**

```java
package UseToStudyJavaClass.ThreadStudy;

public class MyThread extends Thread{

    @Override
    public void run(){
        for(int i=0;i<10;i++){
            System.out.println(i);
        }
    }
}

```

```java
package UseToStudyJavaClass.ThreadStudy;

public class MyThreadDemo {
    public static void main(String[] args) {
        MyThread mt1 = new MyThread();
        MyThread mt2 = new MyThread();

        mt1.start();
        mt2.start();
    }
}

```

结果会交替打印，但是最终都是输出从0到9的结果。

**第二种：**

```java
package UseToStudyJavaClass.ThreadStudy;

public class MyRunnable implements Runnable {
    @Override
    public void run(){
        for(int i=21;i<400;i++){
            System.out.println(i);
        }
    }
}
```

```java
package UseToStudyJavaClass.ThreadStudy;

public class MyThreadDemo {
    public static void main(String[] args) {
        MyRunnable mr1 = new MyRunnable();
        Thread t1 = new Thread(mr1);
        Thread t2 = new Thread(mr1);

        t1.start();
        t2.start();
    }
}

```

可见其为新建Thread，并且将Runnable的接口传进去。

打印的结果也是一样，交替进行，但是最终都会打出来一样的结果。

## 4.5 多线程的实现需要注意的细节

### 4.5.1 run() 和 start() 的方法区别

- run() 是直接跑一遍线程内部的代码，跑完就结束了，和普通代码没什么不同

- start() 是**启动线程**，然后由 JVM 来执行其 run() 方法。

### 4.5.2 JVM的启动是单线程还是多线程的？

JVM 的启动是多线程的。至少不仅有main线程，还有一个GC线程，不然谁来执行扫描呢？

### 4.5.3  一般用哪种方式实现多线程？

一般我们会使用实现 Runnable 接口的方法，原因有两点：

1. Java 之中是不允许多重继承的，使用实现接口的方法可以避免这个限制。
2. 应该实现运行机制和运行任务解耦，说白了，线程的执行和线程的执行任务本身应该尽量去分离。

# 5. Thread 源码剖析

## 5.1 起名和改名

Thread的名字不可以为空，不然会报NPE。如果在创建的时候没有给名字，那么会自动以“Thread-xxxxxx"的格式来起名，其中xxxx是递增的，源码如下：

```java
 /**
     * Allocates a new {@code Thread} object. This constructor has the same
     * effect as {@linkplain #Thread(ThreadGroup,Runnable,String) Thread}
     * {@code (null, null, gname)}, where {@code gname} is a newly generated
     * name. Automatically generated names are of the form
     * {@code "Thread-"+}<i>n</i>, where <i>n</i> is an integer.
     */
    public Thread() {
        init(null, null, "Thread-" + nextThreadNum(), 0);
    }
```

其中的 `nextThreadNum()` 为：

```java
  /* For autonumbering anonymous threads. */
    private static int threadInitNumber;
    private static synchronized int nextThreadNum() {
        return threadInitNumber++;
    }
```

那么可以看到其本身就是递增的。这个`threadInitNumber`也是从0开始，这样就可以避免重名的现象。注意到那个`synchronized`没？保证多线程条件下也是可用的。

那么如果想给线程起个名呢？

```java
				MyRunnable mr1 = new MyRunnable();
        Thread t1 = new Thread(mr1,"名字1");
        Thread t2 = new Thread(mr1,"名字2");
        t1.setName("我改名了");
```

这样就可以了。要么在新建Thread 的时候直接给名字，要么使用`setName()`方法进行改名。

```java
   /**
     * Changes the name of this thread to be equal to the argument
     * <code>name</code>.
     * <p>
     * First the <code>checkAccess</code> method of this thread is called
     * with no arguments. This may result in throwing a
     * <code>SecurityException</code>.
     *
     * @param      name   the new name for this thread.
     * @exception  SecurityException  if the current thread cannot modify this
     *               thread.
     * @see        #getName
     * @see        #checkAccess()
     */
    public final synchronized void setName(String name) {
        checkAccess();
        if (name == null) {
            throw new NullPointerException("name cannot be null");
        }

        this.name = name;
        if (threadStatus != 0) {
            setNativeName(name);
        }
    }
```

再点进去，发现其首先要`checkAccess()`,即目前正在运行的线程是否有修改这个线程名字的权限。还有个`threadStatus`，这个东西在Thread源码之中的所有部分都没有被修改过，但是还经常会判断其是否为0，源码如下：

```java
    /* Java thread status for tools,
     * initialized to indicate thread 'not yet started'
     */

    private volatile int threadStatus = 0;
```

可见0代表其“还没修改”。那在哪被修改了呢？

参考：https://redspider.gitbook.io/concurrent/di-yi-pian-ji-chu-pian/4

```java
// sun.misc.VM 源码：
public static State toThreadState(int var0) {
    if ((var0 & 4) != 0) {
        return State.RUNNABLE;
    } else if ((var0 & 1024) != 0) {
        return State.BLOCKED;
    } else if ((var0 & 16) != 0) {
        return State.WAITING;
    } else if ((var0 & 32) != 0) {
        return State.TIMED_WAITING;
    } else if ((var0 & 2) != 0) {
        return State.TERMINATED;
    } else {
        return (var0 & 1) == 0 ? State.NEW : State.RUNNABLE;
    }
}
```

### 5.1.1 关于start()的两个引申问题

1. 反复调用同一个线程的start()方法是否可行？
2. 假如一个线程执行完毕（此时处于TERMINATED状态），再次调用这个线程的start()方法是否可行？

先上start() 的源码：

```java
public synchronized void start() {
    if (threadStatus != 0)
        throw new IllegalThreadStateException();

    group.add(this);

    boolean started = false;
    try {
        start0();
        started = true;
    } finally {
        try {
            if (!started) {
                group.threadStartFailed(this);
            }
        } catch (Throwable ignore) {

        }
    }
}
```

这两个问题和上面的threadStatus息息相关，其答案如下：

1. 不可行。因为在调用完一次start() 之后其内部的threadStatus 就改变不为0了，那么这种情况下其判断不为0就会直接抛出异常。
2. 不可行。threadStatus为2代表当前线程状态为TERMINATED。那么判断其不为0，还是会直接抛出异常。

我们现在再回到上面那个改名的部分：

如果threadStatus为0，意味着其还没有初始化，那么直接set `this.name=name`就完事了。但是如果不为0，那么意味着已经不在初始化状态了，就要进入下面的`setNativeName(name)` 方法之中。这个native方法就是JVM内部的方法，java源码之中已经不包括了。

这里有个很有趣的现象：可能会有指令重排序，比如我这段代码输出的结果可能不同：

```java
package UseToStudyJavaClass.ThreadStudy;

public class MyThreadDemo {
    public static void main(String[] args) {
        System.out.println(Thread.currentThread().getName());
        MyThread mt1 = new MyThread();
        MyThread mt2 = new MyThread();

        mt1.start();
        mt2.start();

        MyRunnable mr1 = new MyRunnable();
        Thread t1 = new Thread(mr1,"名字1");
        Thread t2 = new Thread(mr1,"名字2");

        t1.start();
        t2.start();
        t1.setName("我改名了1");
        System.out.println(t1.getName());
    }
}

```

其可能为：

```java
main
MyThread Thread-1
MyThread Thread-0
我改名了1
MyRunnable 名字2
MyRunnable 我改名了1
```

也可能为：

```java
main
MyThread Thread-0
MyThread Thread-1
MyRunnable 名字1
我改名了1
MyRunnable 名字2
```

## 5.2 守护线程

守护线程也就是服务线程，当主线程和其他所有线程都结束的时候守护线程会自动结束。比如GC线程就是一种守护线程。

守护线程的使用方法是`thread.setDaemon(true)`。

使用守护线程要注意的地方：

1. 守护线程必须在本线程启动之前就设置好
2. 守护线程永远不要访问共享资源（比如数据库或者文件），因为可能一半就挂了。
3. 守护线程之中产生的新线程也是守护线程

```java
    public final void setDaemon(boolean on) {
        checkAccess();
        if (isAlive()) {
            throw new IllegalThreadStateException();
        }
        daemon = on;
    }
```

如果在线程启动之后再设置，那么其会抛出`IllegalThreadStateException()`。比如下面这段就会：

```java
MyRunnable mr1 = new MyRunnable();
        Thread t1 = new Thread(mr1,"名字1");
        Thread t2 = new Thread(mr1,"名字2");


        t1.start();
        t2.start();

        t2.setDaemon(true);
```

## 5.3 线程优先级

线程优先级只是代表其获得CPU时间片的几率更高，而不是高优先级的线程一定会在低优先级的线程之前完成任务。

```java
    /**
     * The minimum priority that a thread can have.
     */
    public final static int MIN_PRIORITY = 1;

   /**
     * The default priority that is assigned to a thread.
     */
    public final static int NORM_PRIORITY = 5;

    /**
     * The maximum priority that a thread can have.
     */
    public final static int MAX_PRIORITY = 10;
```

java之中默认的优先级是5，最小1，最大10。可以使用`setPriority()`实现。

```java
    public final void setPriority(int newPriority) {
        ThreadGroup g;
        checkAccess();
        if (newPriority > MAX_PRIORITY || newPriority < MIN_PRIORITY) {
            throw new IllegalArgumentException();
        }
        if((g = getThreadGroup()) != null) {
            if (newPriority > g.getMaxPriority()) {
                newPriority = g.getMaxPriority();
            }
            setPriority0(priority = newPriority);
        }
    }
```

首先检查是否超过最小最大范围，之后如果这个线程是属于线程组的，那么优先级不得高于此线程组。最后，直接一个native方法搞定。

这个线程组又是啥呢？线程是它的创建者的线程组的成员。其作用是为了确定权限，Gosling的说法：“线程组中的线程可以修改组内的其他线程，包括那些位于分层结构最深处的。一个线程不能修改位于自己所在组或者下属组之外的任何线程”。

## 5.4 线程的生命周期

### 5.4.1 sleep() 方法

### 5.4.2 yield() 方法

### 5.4.3 join() 方法

### 5.4.4 interupt() 方法

