---
layout:     post   				    # 使用的布局（不需要改）
title:      Build a Spring from Zero  		# 标题 
subtitle:          #副标题
date:       2020-03-28		# 时间
author:     Haiming 						# 作者
header-img: img/post-bg-2015.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - 编程
    - Java
    - Spring
---

# 1. IoC and AOP

IoC: Inversion of Control, or Dependency Injection(DI). In my understanding, it is we put business class and configuration file into Spring container, and then it can produce a system that all dependencies of class already done, which already can use.



![1585405647747](../img/1585405647747.png)

The dependency information can be done by XML file, by Spring Annotations like @Autowired, or some Java Annotations like @Configuration. 

AOP(Aspect Oriented Programming):  Also comes from reality problems. Such as we have some functional modules, like User Management Module and Order Management Module, they not only have relationships with each other, also have relationships with some non-functional modules, such as log system and security system. 

If we only in functional systems call non-functional systems, even only very small change of non-functional modules we need to change methods in functional modules. This can not be endured.

![1585406318025](../img/1585406318025.png)

So we can isolate the functional codes and non-functional codes like this way. 

# 2. Steps for unit test

One unit test has 4 steps:

1. **Think** and write test cases: which always included **corner cases** and **normal cases**.
2. Run the test case and find error.
3. Write **just enough** code to make test cases.
4. Refactor code to make it clean.

Then loop until all functions are developed.

# 3. Step1: How to build a class from XML file?

This is a class I call it `DefaultBeanFactory`, which I used to generate bean from XML file. 

First step, I used a package called `dom4j` which maven format is this:

```xml
		<dependency>
			<groupId>dom4j</groupId>
			<artifactId>dom4j</artifactId>
			<version>1.6.1</version>
		</dependency>
```

This package produce abilities for reading XML files. Use this, I can change XML file into inputStream and then read XML elements. 

The XML file I want to analysis is this one:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
           http://www.springframework.org/schema/beans/spring-beans.xsd">
  
  <bean id="petStore"
        class="org.litespring.service.v1.PetStoreService" >   
  </bean> 

</beans>
```

So we can see the bean has elements `id` and `class` in pair. After analysis, I will put them into a map, so that we don;'t need to analysis it once and once again. 

I use another class `GenericBeanDefination` which implements the interface `BeanDefination`, produces constructor like this:

```java
package org.litespring.beans.factory.support;

import org.litespring.beans.BeanDefinition;

public class GenericBeanDefinition implements BeanDefinition {
	private String id;
	private String beanClassName;
	public GenericBeanDefinition(String id, String beanClassName) {
		
		this.id = id;
		this.beanClassName = beanClassName;
	}
	public String getBeanClassName() {
		
		return this.beanClassName;
	}

}
```

Then I need one thing that can convert `BeanDefination` into Class, which is a `classloader`. Here I use ClassUtil which jdk provided. 

Simply saying, `ClassUtil` has 3 steps to get a classLoader, the first step is to use `Thread.currentThread().getContextClassLoader()` to get the currentThread's context classloader. After that, it uses `ClassUtils.class.getClassLoader()` to get itself's `classLoader`, then if still cannot get, it will use `getSystemClassLoader()`, which is also the `AppClassLoader`

> `ClassLoader.getSystemClassLoader` will often return `ApplicationClassLoader`, it only load class file under `classpath`,which is often the ` bin/` in Java SE. And in Java EE, `Thread.currentThread().getContextClassLoader()` also returns `ApplicationClassLoader`
>
> But in Java EE. class of our project is from `WebAppClassLoader`, which can be get from `	Thread.currentThread().getContextClassLoader()`. 

