---
layout:     post   				    # 使用的布局（不需要改）
title:      Java相关知识点梳理				# 标题 
subtitle:   Java基础，包括Java环境，Java基本类型，抽象类与接口等等 #副标题
date:       2019-09-04 				# 时间
author:     Haiming 						# 作者
header-img: img/post-bg-2015.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - 编程
    - Java

---

忙里偷闲，扎实基础才是正经事。
8说了，开冲！

# 1. JDK和JRE有什么区别

这个知识点我想只要搞Java的都知道……

- JDK：Java Development Kit的简称，Java开发工具包，提供了Java的开发环境和运行环境（JRE）
- JRE: Java Runtime Environment 的简称，Java 运行环境

JDK之中其实包含了JRE还有javac，一个用来编译源码的编译器（.java->.class），还有很多相关的工具。

# 2. == 和 equals 的区别是什么

首先，在java之中我们都知道数据分为两种类型：基本类型，包括 integer,boolean 等等，还有引用类型（各种Object）。
对于两种类型而言，== 的作用是不同的，差别如下：

- 基本类型：比较值是否相同
- 引用类型：比较引用是否相同
  下面是代码实例：

```java
String x= "String";
String y= "String";
String z= new String("String");
System.out.println(x==y);//This one is true because they are both basic type
System.out.println(x==z);//This one is false because it is comparision between the basic type and object.
System.out.println(x.equls(y));//This one returns true,because the function "euqals" only compare the value between these two.
System.out.println(x.equls(z));//This one returns true,because the function "euqals" only compare the value between these two.
```

解读如下：
因为x和y指向 是同一个引用，所以 == 是 true。但是 new String() 方法则重新开辟了内存空间，所以 == 结果是 false， 但是 equals 比较的一直是值，所以其最后都为 true
**equals 解读 **
equals 本质就是 == ， 但是 String 和 Integer 等等重写了 equals 方法，将其变成了值比较。
首先看默认情况下equals 比较一个有相同值的对象：

```java
class Cat{
    public Cat(String name){
        this.name=name;
    }
    private String name;
    public String getName(){
        return name;
    }
    public void setName(String name){
        this.name=name;
    }
}

Cat c1=new Cat("Meow");
Cat c2=new Cat("Meow");
System.out.println(c1.equals(c2));//false
```

结果最后是fasle，原因是：

```java
public boolean equals(Object obj){
    return (this == obj);
    }
```

所以 equals 本质上就是 ==
那为什么两个相同值的 String 对象，返回的却是 true ？ 因为之前我们提到过的， Java 将整个 String 之中的 equals 方法重写，变成了下面的代码：

```java
public boolean equals(Object anObject){
    if(this == anObject){
        return true;
    }
    if(anObject instanceof String){
        String anotherString = (String)anObject;
        int n = value.length;
        if(n == anotherString.vakue.length){
            char v1[] = value;
            char v2[] = anotherString.value;
            int i = 0;
            while (n-- != 0){
                if(v1[i] != v2[i])
                    return false;
                i++;
            }
            return true;
        }
    }
    return false;
}
```

# 3. 两个对象的 hashCode() 相同，则 equals() 也一定为 true, 对吗?

不对。两个对象的 hashCode() 相同，equals() 不一定为 true。
代码示例：

```java
String str1 = "通话";
String str2 = “重地；
System.out.pringln(String.format("str1:%d | str2: %d",str1.hashCode(),str2.hashCode()));
System.out.println(str1.equals(str2));
```

执行的结果：

```
str1: 1179395 | str2: 1179395
false
```

可以看到，”通话“和”重地“的hashCode()是相同的，然而equals()则是 false，因为在 HashTable之中， hashCode() 相等只是说明二者的和Hash 相同，但是 Hash值相同，并不能得出键值对相等。

# 4. final 在 Java 之中有什么作用？

- final修饰的类叫最终类，该类不可以被继承
- final修饰的方法不可以被overwrite，但是可以被继承（方法可以，类不可以）
- final修饰的变量叫做常量，常量必须被初始化，初始化之后的值就不可被修改
- final不能用于修饰构造方法

*注：父类的private成员方法是不能被子类方法覆盖的，因此父类之中private类型的方法默认是final类型的*

上面的这三种是比较抽象的说法，下面我就 final 的意义做具体的讲述。

参照博客：
https://blog.csdn.net/andie_guo/article/details/12885885

Java 关键字 final 有”这是无法改变的“，或者”终态的“含义。其可以修饰非抽象类，非抽象类成员方法和变量。可以出于两种理解阻止改变：设计或者效率。

##### 1. final数据

- 一个永不改变的**编译时**常量
- 一个在运行时被初始化的值，而之后无法改变
- 一个既是static又是final的域，是一段不能改变的存储空间

所以在数据部分，final 的作用是提供一个永远不会变化的常量，但是其在不同的数据类型之中表现也不相同：

- 基本数据类型： final 让 value 保持不变
- 对象引用(object reference): final仅仅让 reference 保持不变，也就是该指针不可以指向其他对象，但是所指向的对象本身内容可以改变。
- 数组类型使用final时，final的使用使数组引用很顶不变，数组内部的数据如果不是final型，可以进行修改。（和上述的对象引用类似）

**final和static的差别**

- final指明数据为一个常量，恒定无法修改
- static指明数据只占用一份内存区域

```java
public class FinalData {
	private final int valueOne = 3;
	private int valueTwo = 4;
	private final Value v1 = new Value(4);
	private Value v2 = new Value(10);
	private final int[] a = {1,2,3,4,5,6,7,8,9};
	private int[] b = {1,2,3,4,5,6,7,8,9};
	private static final int VAL_TWO = 3;
	
	public static void main(String[] args) {
		FinalData finalData = new FinalData();
		/*-----------基本类型测试------------------------------------*/
//		finalData.valueOne = 4;//valueOne是常量，无法修改
		finalData.valueTwo = 14;//valueTwo不是常量，可以修改
		
		/*-----------对象类型测试------------------------------------*/
//		finalData.v1 = new Value(5);//v1对象是final型常量，其引用是无法修改的。
		finalData.v2 = new Value(20);//v2对象final型常量，其引用可以修改。
		finalData.v1.i = 5;//v1对象的成员变量不是final型，可以修改
		
		/*-----------数组类型测试------------------------------------*/
//		finalData.a = new int[3];//数组a是final型，无法修改a的引用
		finalData.b = new int[13];//数组b不是final型，可以对其引用进行修改
		for(int i=0;i<finalData.a.length;i++) 
			finalData.a[i]++;//数组a内部数据是int型，不是final型，可以修改
		
		/*-----------static final类型测试------------------------------------*/
//		finalData.VAL_TWO = 4;
		//定义为private，只能被本类的方法调用；定义为static，则强调只有一份，且只被执行一次；定义为final，则说明它是一个常量，无法被修改。
		
	}
}
```

**2. final方法**

如果一个类不允许其子类覆盖某个方法，则可以把这个方法声明为final方法。其原因为：

- 从程序员的角度而言，把方法锁定，防止任何继承修改它的意义和实现
- 从整个程序的角度而言，可以使得程序的效率更高。编译器在遇到调用 final 方法的时候会转入内嵌机制，大大提高执行效率。

下面是代码示例：

```java
public class FinalDemo {
 
	public void f(){
		System.out.println("FianlDemo.f()");
	}
	public final void g(){
		System.out.println("FianlDemo.g()");
	}
}

```



```java
public class FinalOverriding extends FinalDemo{
 
	public void f(){
		System.out.println("FinalOverriding.f()");
	}
	
//	public void g(){//无法覆盖父类的final方法g（）
//		System.out.println("FinalOverriding.g()");
//	}
}

```

**3.final 类**

final 类不可以被继承，因此 final 类的method 不会被覆盖，默认都是final的。在设计类时候，如果：

- 这个类不需要有子类
- 类的实现细节不允许改变
- 类不会再被扩展

那么就设计为 final 类。

# 5. Java 之中的 Math.round(-1.5) 等于多少？

结果是 -1。

在数轴上面取值的时候，中间值（0.5）向右取整，所以 +0.5 是向上取整， -0.5 是直接舍弃。

# 6. String属于基础的数据类型么？

String 不是基本的数据类型，基础类型只有八种：

Byte， Boolean，Char，Short，Int，Float，Long，Double。

String属于对象

# 7. Java 之中操作字符串都有哪些类？它们之间有什么区别？



操作字符串的类有： String,StringBuffer,StringBuilder.

String和StringBuffer,StringBuilder的区别在于：String声明的是不可变的对象，每次操作都会生成新的对象，然后将指针指向新的对象。

但是StringBuffer,StringBuilder就是每次都在原有对象的基础之上进行操作，所以如果经常改变String内容的情况下，最好不要使用String，这样会导致不断的创建新的对象，那么效率就会大大降低。

StringBuffer和StringBuilder的区别在于，StringBuffer是线程安全的，但是这种线程安全的保证就是最基础的加锁，所以在不需要线程安全的情况下，最好使用StringBuilder，这样性能更高。

# 8.`String str = "i"` 和 `String str = new String("i")` 一样吗？

不一样。

在之前的有一篇[blog](https://timzhouyes.github.io/2019/07/11/%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95/#211-jvm-%E5%86%85%E5%AD%98%E5%88%92%E5%88%86)之中讲过JVM之中不同的内存分配方式。

在方法区之中的运行时常量池（Runtime Constant Pool） 是方法区的一部分，用于存储编译期就已经生成的字面常量，符号引用，翻译出来的直接引用等等。所以`String str = "i"` 会被分配到常量池之中。而堆内存，作为JVM所管理内存之中最大的一个部分，第二种方式创建的`String str = new String("i");` 会被直接分配到堆内存之中。

# 9. 如何将字符串反转？

使用 StringBuilder 或者 StringBuffer 的 reverse() 方法。

# 10. String类常用的方法都有哪些？

- indexOf(): 返回指定字符的索引
- charAt(): 返回指定索引处的字符
- replace(): 字符串替换
- trim(): 去除字符两端空白
- split():分割字符串，返回一个分割后的字符串数组
- getBytes(): 返回字符串的 byte 类型数组
- length(): 返回字符串长度
- toLowerCase():将字符串转换成小写字母
- toUpperCase(): 将字符串转换成大写字母
- substring(): 截取字符串
- equals(): 字符串比较

# 11. 抽象类必须要有抽象方法吗？

https://www.jianshu.com/p/0530e14192b4

首先说一下抽象类和抽象方法：

## 11.1 抽象类

1. 为什么有抽象类？

我们都知道，父类是将子类之中所共同具有的属性和方法进行抽取，但是很多方法在确定父类的情况下并不能提前确定其实现，那么这种情况下，我们暂时将其定义为抽象，在以后的子类再进行继续的重用。

所以抽象类的意义就在于此： 将相同的但是不确定的特点先提取出来，为了以后的重用。定义成抽象类的目的，就是在子类当中实现抽象方法。

2. 抽象类和抽象方法的区别？

有抽象方法的类就是抽象类，但是抽象类之中也可以不包含抽象方法。抽象类的声明使用abstract关键字。

3. 抽象类的基本特性和使用方法

- 抽象类不可以被实例化，因为抽象类之中**可能**具有抽象方法（之后会提及抽象类和抽象方法之间的关系），所以抽象类算是一种**不完整的类**，直接实例化就失去意义了。
- 要使用抽象类，就必须有子类，使用extends继承。一个子类只可以继承**一个**抽象类。
- 如果抽象类的子类不是抽象类，那么就必须复写抽象类之中的所有抽象方法。如果子类没有实现父类的抽象方法，那么必须将子类也定义为 abstract 类。

4. 抽象类的使用限制

- 抽象类可以有构造方法。由于抽象类也是一个类，内部可以存在一些属性，那么抽象类之中也可以有构造方法，其目的是为了属性的初始化。且子类对象实例化的时候，也满足先执行父类构造，再执行子类构造的顺序。也就是说，在子类和父类这个情况之下，抽象类并没有什么特殊。
- 抽象类不可以使用 final 声明。这个原因我们之前有讲到过，那就是 final 定义的类不可以有子类，但是抽象类的实现方法就是要依靠子类，所以不可以。
- 抽象类能否使用 static 声明？ 

> 外部抽象类不允许使用 static 声明，但是内部抽象类可以使用 static 声明。使用 static 声明的内部抽象类相当于一个外部抽象类，继承的时候使用"外部类.内部类"的形式表示类名称。

内部抽象类使用示例：

```java
abstract class A{
    //static定义的内部类属于外部类
    static abstract class B{
        public abstract void print();
    }
}

class C extends A.B{
    public void print(){
        System.out.println("**********");
    }
}

public class TestDemo {
    public static void main(String[] args) {
        //向上转型
        A.B ab = new C();
        ab.print();
    }
}
```

结果：

```java
**********
```

可见这种情况之中，直接使用 A.B 来使用当前的类。

- 抽象类之中的 static 方法可以直接调用

下面是示例代码：

```java
abstract class A{
    public static void print(){
        System.out.println("Hello World !");
    }
}

public class TestDemo {
    public static void main(String[] args) {
        A.print();
    }
}
```

结果如下：

```java
Hello World !
```

上面的代码之中即为直接使用抽象类之中的 static 方法，从而直接输出的例子。并没有任何初始化整个 Class 的行为。

- 抽象类之中，如果只需要一个特定的系统子类操作，那么可以忽略掉外部子类。这样的设计作用为对用户隐藏不需要知道的子类。

示例如下：

```java
abstract class A{
    public abstract void print();

    //内部抽象类子类
    private static class B extends A{
        //覆写抽象类的方法
        public void print(){
            System.out.println("Hello World !");
        }
    }

    //这个方法不受实例化对象的控制
    public static A getInstance(){
        return new B();
    }
}

public class TestDemo {
    public static void main(String[] args) {
        //此时取得抽象类对象的时候完全不需要知道B类这个子类的存在
        A a = A.getInstance();
        a.print();
    }
}
```

结果为：

```java
Hello World !
```

在上面的代码之中， main 函数之中直接使用 getInstance() 的方法得到了其内部的一个抽象类子类，但是完全不知道 B 子类的存在。

## 11.2 抽象方法

1. 抽象方法和普通方法的区别

在普通方法上面都会有一个'{}'，来表示方法体。有方法体的方法一定可以直接被对象引用。

抽象方法，指的是

- 没有方法体的方法
- 还必须使用关键字 abstract 作为修饰。
- 抽象方法必须为 public 或者 protected。因为如果是 private，则不可以被子类继承，子类就无法实现该方法。默认情况是 public

抽象方法一例：

```java
//没有方法体，有abstract关键字做修饰
public abstract void xxx();
```

所以本题的答案就出来了：抽象类不一定要有抽象方法。下面是示例：

```java
abstract class Cat{
	public static void sayHi(){
		System.out.println("hi~");
	}
}
```

上面的这个例子里面，抽象类并没有任何抽象方法，但是依旧可以正常运行。

# 12. 普通类和抽象类有何区别？

上面的抽象类介绍之中都已经将这些讲清楚，下面简要说一下答案。

- 普通类不能包含抽象方法，抽象类可以包含抽象方法
- 抽象类不能直接实例化，但是普通类可以直接实例化。

# 13. 抽象类可以用 final 修饰吗？

答案上面提及过。不可以。

# 14. 接口(interface) 和抽象类(abstract class) 有什么区别？

参考链接：
https://blog.csdn.net/chenssy/article/details/12858267

## 14.1 什么是接口(interface)

上面讲过了抽象类，那么这里将接口是什么也好好梳理一下：

首先要澄清的一点是，接口**不是类**，从我们不可以实例化一个接口就可以看出来这一点。

接口，是用来建立类与类之间的协议，其所提供的仅仅是一种形式，不是其具体的实现。同时该接口的实现类，必须要实现该接口的所有方法。通过 implement 关键字，其表示该类在遵循某些指定的接口，并且也表示着：”interface 只是其外观，但是现在要声明其是如何工作的”。

接口，是抽象类的延申，java 为了保证数据安全，是不可以多重继承的，也就是说继承只可以存在一个父类。但是接口不同，一个类可以同时 implement 多个接口，不管这些接口之间有没有关系。所以接口弥补了抽象类不可以多重继承的缺陷。

在使用接口的过程之中需要注意以下几个问题：

1. Interface的所有方法访问权限被自动声明为 public， 确切的说只能为 public。
2. 接口之中可以定义“成员变量”，或者可以说是不可变的常量。因为接口之中的“成员变量”会自动变为 public static final。在接口之中的成员变量可以通过类命名直接访问：ImplementClass.name
3. 接口之中**不存在**实现的方法。
4. 实现接口的*非抽象类*必须要实现该接口的所有方法，但是**抽象类可以不用实现**。
5. 在实现多接口实现的时候一定要避免方法的重复。

## 14.2 抽象类和接口在具体方向之上的区别

下面从语法层次和设计层次两个方面来对抽象类和接口进行阐述。

### 14.2.1 语法层次

在语法层次，java 对抽象类和接口分别给出了不同的定义。下面用 Demo 类来说明其之间的不同之处。

使用抽象类来实现：

```java
public abstract class Demo {
    abstract void method1();
    
    
    void method2(){
        //实现
    }
}
```

使用接口来实现：

```java
interface Demo {
    void method1();
    void method2();
}
```

可见，在抽象类之中，抽象类可以有任意范围的成员数据，同时也可以有自己的非抽象方法。但是在 interface 之中，只可以有静态，不可以修改的成员数据，尽管在接口之中我们一般不使用成员数据。同时，在 interface 之中的方法都必须是抽象的，不可以有哪种方法的具体实现。

### 14.2.2 设计层次

从设计理念来彻底剖析二者区别，可以得到：

1. 抽象层次不同。抽象类，是对类抽象；而接口是对行为的抽象。抽象类，要对整个类的整体做抽象，包括属性和行为等等，但是接口，却是对类的行为部分做抽象。
2. 跨域不同。























