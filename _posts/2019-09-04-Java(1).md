---
layout:     post   				    # 使用的布局（不需要改）
title:      Java相关知识点梳理				# 标题 
subtitle:   Java基础 #副标题
date:       2019-09-04 				# 时间
author:     Haiming 						# 作者
header-img: img/post-bg-2015.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - 编程
    - Java

---

忙里偷闲，扎实基础才是正经事。
8说了，开冲！

# 1. JDK和JRE有什么区别

这个知识点我想只要搞Java的都知道……

- JDK：Java Development Kit的简称，Java开发工具包，提供了Java的开发环境和运行环境（JRE）
- JRE: Java Runtime Environment 的简称，Java 运行环境

JDK之中其实包含了JRE还有javac，一个用来编译源码的编译器（.java->.class），还有很多相关的工具。

# 2. == 和 equals 的区别是什么

首先，在java之中我们都知道数据分为两种类型：基本类型，包括 integer,boolean 等等，还有引用类型（各种Object）。
对于两种类型而言，== 的作用是不同的，差别如下：

- 基本类型：比较值是否相同
- 引用类型：比较引用是否相同
  下面是代码实例：

```java
String x= "String";
String y= "String";
String z= new String("String");
System.out.println(x==y);//This one is true because they are both basic type
System.out.println(x==z);//This one is false because it is comparision between the basic type and object.
System.out.println(x.equls(y));//This one returns true,because the function "euqals" only compare the value between these two.
System.out.println(x.equls(z));//This one returns true,because the function "euqals" only compare the value between these two.
```

解读如下：
因为x和y指向 是同一个引用，所以 == 是 true。但是 new String() 方法则重新开辟了内存空间，所以 == 结果是 false， 但是 equals 比较的一直是值，所以其最后都为 true
**equals 解读 **
equals 本质就是 == ， 但是 String 和 Integer 等等重写了 equals 方法，将其变成了值比较。
首先看默认情况下equals 比较一个有相同值的对象：

```java
class Cat{
    public Cat(String name){
        this.name=name;
    }
    private String name;
    public String getName(){
        return name;
    }
    public void setName(String name){
        this.name=name;
    }
}

Cat c1=new Cat("Meow");
Cat c2=new Cat("Meow");
System.out.println(c1.equals(c2));//false
```

结果最后是fasle，原因是：

```java
public boolean equals(Object obj){
    return (this == obj);
    }
```

所以 equals 本质上就是 ==
那为什么两个相同值的 String 对象，返回的却是 true ？ 因为之前我们提到过的， Java 将整个 String 之中的 equals 方法重写，变成了下面的代码：

```java
public boolean equals(Object anObject){
    if(this == anObject){
        return true;
    }
    if(anObject instanceof String){
        String anotherString = (String)anObject;
        int n = value.length;
        if(n == anotherString.vakue.length){
            char v1[] = value;
            char v2[] = anotherString.value;
            int i = 0;
            while (n-- != 0){
                if(v1[i] != v2[i])
                    return false;
                i++;
            }
            return true;
        }
    }
    return false;
}
```

# 3. 两个对象的 hashCode() 相同，则 equals() 也一定为 true, 对吗?

不对。两个对象的 hashCode() 相同，equals() 不一定为 true。
代码示例：

```java
String str1 = "通话";
String str2 = “重地；
System.out.pringln(String.format("str1:%d | str2: %d",str1.hashCode(),str2.hashCode()));
System.out.println(str1.equals(str2));
```

执行的结果：

```
str1: 1179395 | str2: 1179395
false
```

可以看到，”通话“和”重地“的hashCode()是相同的，然而equals()则是 false，因为在 HashTable之中， hashCode() 相等只是说明二者的和Hash 相同，但是 Hash值相同，并不能得出键值对相等。

# 4. final 在 Java 之中有什么作用？

- final修饰的类叫最终类，该类不可以被继承
- final修饰的方法不可以被overwrite，但是可以被继承（方法可以，类不可以）
- final修饰的变量叫做常量，常量必须被初始化，初始化之后的值就不可被修改
- final不能用于修饰构造方法

*注：父类的private成员方法是不能被子类方法覆盖的，因此父类之中private类型的方法默认是final类型的*

上面的这三种是比较抽象的说法，下面我就 final 的意义做具体的讲述。

参照博客：
https://blog.csdn.net/andie_guo/article/details/12885885

Java 关键字 final 有”这是无法改变的“，或者”终态的“含义。其可以修饰非抽象类，非抽象类成员方法和变量。可以出于两种理解阻止改变：设计或者效率。

##### 1. final数据

- 一个永不改变的**编译时**常量
- 一个在运行时被初始化的值，而之后无法改变
- 一个既是static又是final的域，是一段不能改变的存储空间

所以在数据部分，final 的作用是提供一个永远不会变化的常量，但是其在不同的数据类型之中表现也不相同：

- 基本数据类型： final 让 value 保持不变
- 对象引用(object reference): final仅仅让 reference 保持不变，也就是该指针不可以指向其他对象，但是所指向的对象本身内容可以改变。
- 数组类型使用final时，final的使用使数组引用很顶不变，数组内部的数据如果不是final型，可以进行修改。（和上述的对象引用类似）

**final和static的差别**

- final指明数据为一个常量，恒定无法修改
- static指明数据只占用一份内存区域

```java
public class FinalData {
	private final int valueOne = 3;
	private int valueTwo = 4;
	private final Value v1 = new Value(4);
	private Value v2 = new Value(10);
	private final int[] a = {1,2,3,4,5,6,7,8,9};
	private int[] b = {1,2,3,4,5,6,7,8,9};
	private static final int VAL_TWO = 3;
	
	public static void main(String[] args) {
		FinalData finalData = new FinalData();
		/*-----------基本类型测试------------------------------------*/
//		finalData.valueOne = 4;//valueOne是常量，无法修改
		finalData.valueTwo = 14;//valueTwo不是常量，可以修改
		
		/*-----------对象类型测试------------------------------------*/
//		finalData.v1 = new Value(5);//v1对象是final型常量，其引用是无法修改的。
		finalData.v2 = new Value(20);//v2对象final型常量，其引用可以修改。
		finalData.v1.i = 5;//v1对象的成员变量不是final型，可以修改
		
		/*-----------数组类型测试------------------------------------*/
//		finalData.a = new int[3];//数组a是final型，无法修改a的引用
		finalData.b = new int[13];//数组b不是final型，可以对其引用进行修改
		for(int i=0;i<finalData.a.length;i++) 
			finalData.a[i]++;//数组a内部数据是int型，不是final型，可以修改
		
		/*-----------static final类型测试------------------------------------*/
//		finalData.VAL_TWO = 4;
		//定义为private，只能被本类的方法调用；定义为static，则强调只有一份，且只被执行一次；定义为final，则说明它是一个常量，无法被修改。
		
	}
}
```

**2. final方法**

如果一个类不允许其子类覆盖某个方法，则可以把这个方法声明为final方法。其原因为：

- 从程序员的角度而言，把方法锁定，防止任何继承修改它的意义和实现
- 从整个程序的角度而言，可以使得程序的效率更高。编译器在遇到调用 final 方法的时候会转入内嵌机制，大大提高执行效率。

下面是代码示例：

```java
public class FinalDemo {
 
	public void f(){
		System.out.println("FianlDemo.f()");
	}
	public final void g(){
		System.out.println("FianlDemo.g()");
	}
}

```



```java
public class FinalOverriding extends FinalDemo{
 
	public void f(){
		System.out.println("FinalOverriding.f()");
	}
	
//	public void g(){//无法覆盖父类的final方法g（）
//		System.out.println("FinalOverriding.g()");
//	}
}

```

**3.final 类**

final 类不可以被继承，因此 final 类的method 不会被覆盖，默认都是final的。在设计类时候，如果：

- 这个类不需要有子类
- 类的实现细节不允许改变
- 类不会再被扩展

那么就设计为 final 类。

# 5. Java 之中的 Math.round(-1.5) 等于多少？

结果是 -1。

在数轴上面取值的时候，中间值（0.5）向右取整，所以 +0.5 是向上取整， -0.5 是直接舍弃。

# 6. String属于基础的数据类型么？

String 不是

