---
layout:     post   				    # 使用的布局（不需要改）
title:      Java相关知识点梳理				# 标题 
subtitle:   Java基础 #副标题
date:       2019-09-04 				# 时间
author:     Haiming 						# 作者
header-img: img/post-bg-2015.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - 编程
    - Java
---
忙里偷闲，扎实基础才是正经事。
8说了，开冲！
# 1. JDK和JRE有什么区别
这个知识点我想只要搞Java的都知道……
- JDK：Java Development Kit的简称，Java开发工具包，提供了Java的开发环境和运行环境（JRE）
- JRE: Java Runtime Environment 的简称，Java 运行环境

JDK之中其实包含了JRE还有javac，一个用来编译源码的编译器（.java->.class），还有很多相关的工具。

# 2. == 和 equals 的区别是什么
首先，在java之中我们都知道数据分为两种类型：基本类型，包括 integer,boolean 等等，还有引用类型（各种Object）。
对于两种类型而言，== 的作用是不同的，差别如下：
- 基本类型：比较值是否相同
- 引用类型：比较引用是否相同
下面是代码实例：
```java
String x= "String";
String y= "String";
String z= new String("String");
System.out.println(x==y);//This one is true because they are both basic type
System.out.println(x==z);//This one is false because it is comparision between the basic type and object.
System.out.println(x.equls(y));//This one returns true,because the function "euqals" only compare the value between these two.
System.out.println(x.equls(z));//This one returns true,because the function "euqals" only compare the value between these two.
```
解读如下：
因为x和y指向 是同一个引用，所以 == 是 true。但是 new String() 方法则重新开辟了内存空间，所以 == 结果是 false， 但是 equals 比较的一直是值，所以其最后都为 true
**equals 解读 **
equals 本质就是 == ， 但是 String 和 Integer 等等重写了 equals 方法，将其变成了值比较。
首先看默认情况下equals 比较一个有相同值的对象：
```java
class Cat{
    public Cat(String name){
        this.name=name;
    }
    private String name;
    public String getName(){
        return name;
    }
    public void setName(String name){
        this.name=name;
    }
}

Cat c1=new Cat("Meow");
Cat c2=new Cat("Meow");
System.out.println(c1.equals(c2));//false
```
结果最后是fasle，原因是：
```java
public boolean equals(Object obj){
    return (this == obj);
    }
```
所以 equals 本质上就是 ==
那为什么两个相同值的 String 对象，返回的却是 true ？ 因为之前我们提到过的， Java 将整个 String 之中的 equals 方法重写，变成了下面的代码：
```java
public boolean equals(Object anObject){
    if(this == anObject){
        return true;
    }
    if(anObject instanceof String){
        String anotherString = (String)anObject;
        int n = value.length;
        if(n == anotherString.vakue.length){
            char v1[] = value;
            char v2[] = anotherString.value;
            int i = 0;
            while (n-- != 0){
                if(v1[i] != v2[i])
                    return false;
                i++;
            }
            return true;
        }
    }
    return false;
}
```

# 3. 两个对象的 hashCode() 相同，则 equals() 也一定为 true, 对吗?
不对。两个对象的 hashCode() 相同，equals() 不一定为 true。
代码示例：
```java
String str1 = "通话";
String str2 = “重地；
System.out.pringln(String.format("str1:%d | str2: %d",str1.hashCode(),str2.hashCode()));
System.out.println(str1.equals(str2));
```

执行的结果：
```
str1: 1179395 | str2: 1179395
false
```
可以看到，”通话“和”重地“的hashCode()是相同的，然而equals()则是 false，因为在 HashTable之中， hashCode() 相等只是说明二者的和Hash 相同，但是 Hash值相同，并不能得出键值对相等。

# 4. final 在 Java 之中有什么作用？
- final修饰的类叫最终类，该类不可以被继承
- final修饰的方法不可以被overwrite，但是可以被继承（方法可以，类不可以）
- final修饰的变量叫做常量，常量必须被初始化，初始化之后的值就不可被修改
- final不能用于修饰构造方法

*注：父类的private成员方法是不能被子类方法覆盖的，因此父类之中private类型的方法默认是final类型的*

上面的这三种是比较抽象的说法，下面我就 final 的意义做具体的讲述。

参照博客：
https://blog.csdn.net/andie_guo/article/details/12885885

Java 关键字 final 有”这是无法改变的“，或者”终态的“含义。其可以修饰非抽象类，非抽象类成员方法和变量。可以出于两种理解阻止改变：设计或者效率。

##### 1. final数据
- 一个永不改变的**编译时**常量
- 一个在运行时被初始化的值，而之后无法改变
- 一个既是static又是final的域，是一段不能改变的存储空间
