---
layout:     post   				    # 使用的布局（不需要改）
title:      《Java特种兵》阅读笔记  		# 标题 
subtitle:   第一篇——Java功底篇       #副标题
date:       2020-02-27		# 时间
author:     Haiming 						# 作者
header-img: img/post-bg-2015.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - 编程
    - Java
---

开干。

# 第一章：看看功底如何

## 1.1 String的例子，见证下功底

下面看看 `equals()` 怎么用：

```java
package JavaTeZhongBing;

public class Chapter1_1 {
    public static void main(String[] args) {
        String a = "a" + "b" + 1;
        String b = "ab1";
        System.out.println(a == b);
    }
}

```

按照之前的想法，是不是a和b两个对象使用`equals()` 结果为false嘛。

结果为`true`。

为什么呢？

要弄清楚以下4点：

1. `==`是做什么的？
2. `equals`是做什么的？
3. a和b在内存之中是如何安排的？
4. 编译时优化的方案

### 1.1.1 关于 `==`

`==`比较内存单元的内容，其实比较的就是一个数字。

在 Java 之中，`==`来匹配的就是两个内存单元的内容是否相同。

分情况：

1. 如果是原始类型，直接比较其值
2. 如果是引用(reference)，比较的是引用的值，其可以被理解为对象的“逻辑地址”。

### 1.1.2 关于 `equals()`

`eqauls()`方法，首先在 Object 之中被定义。

```java
    public boolean equals(Object obj) {
        return (this == obj);
    }
```

可见对于对象，其原始定义之中就是比较对象的地址。

那么这个方法存在的意义是什么呢？就是希望子类可以重写这个方法，实现个性化的对比的功能。比如在String 之中就重写了 `equals()`方法：

```java
   public boolean equals(Object anObject) {
        if (this == anObject) {
            return true;
        }
        if (anObject instanceof String) {
            String anotherString = (String)anObject;
            int n = value.length;
            if (n == anotherString.value.length) {
                char v1[] = value;
                char v2[] = anotherString.value;
                int i = 0;
                while (n-- != 0) {
                    if (v1[i] != v2[i])
                        return false;
                    i++;
                }
                return true;
            }
        }
        return false;
    }
```

提供个性化的`equals()`表达方法，是为了适应多种业务的个性化满足。换句话，如果你想，可以直接强制这个方法返回true，那么比较之后就是和所有参数都相等了。

有的人会问，那`hashCode()` 是不是也需要重写一下呢？

这里有一个概念辨析：有人会认为 `hashCode()` 也是用来标识一个对象。这是大错特错。

`hashCode()`是一个 native 方法，本身返回值默认和`System.identityHashCode(object)`一致。在通常情况下，值是对象头部的一部分二进制位组成的数字，**其虽然具有一定的标识对象的意义**，但是绝对**不等价于地址**，**也绝对不保证没有冲突**。

`hashCode()`的作用，**是产生一个可以标识对象的数字**。这个数字在什么时候需要呢？比如在`HashSet`,`HashMap`之中，基于对象本身产生 key，就可以使用。

`hashCode` 只能说是标识对象，因此在Hash算法之中可以讲对象相对离散开。但是并不是说`hashCode()`值是唯一的，所以在Hash算法之中定位到具体链表后，需要进一步循环链表，然后通过`equals()`来对比值是不是一致的。

换句话，`hashCode()`是用来快速定位数据，而`equals()`是用来对比真实值。

**下面就`hashCode()`和`equals()` 两者之间的资源消耗做一个比较：**

拿String来说，其至少会在第一次调用 hashCode() 方法的时候**遍历所有char[] 数组并且计算hashCode值**，所以两个String进行比较至少会遍历两次char[],如果在期间遇到了并发使用hashCode()的情况，可能还会多很多次调用。可是即使耗费了这么多资源，也依旧是没法确定两个对象相等（前面讲过两个完全不同的对象 hashCode 有可能相同。

但是equals的内部是可以自己去设计逻辑，包括可以先从简单的东西还是比较再到比较复杂的结构，或者先对比地址，长度等等方式将不匹配的东西尽快排除。

### 1.1.3 编译时优化方案

为什么a引用是通过 + 操作来获得对象，b是直接赋值的对象，看起来完全是两个引用，但是最终其指向的是一个内存单元呢？这就是 JVM 之中的“编译时优化”。

是因为编译器在编译代码的时候，就会将`"a"+"b"+1` 作为`"ab1”`。原因是这三个值都是常量，在编译器编译的时候会认为这几个值在程序运行的过程之中也会保持不变，所以无需运行时再计算，就会这样优化。

为了提高效率和节约资源，能提前做的事情编译器就有可能会提前做。但是 JVM 只会优化其可以优化的部分，如果在上面的字符串之中出现了变量，那么就不会在编译阶段进行优化。

**注意：只要JVM不能确定的情况，比如变量这种，JVM一定不会优化。但绝对不代表只要是常量JVM就会提前进行优化。**

小Tip：这也证明了实际上"+" 操作**不一定**比`StringBuilder.append()`慢，如果是编译时合并那么就会更快，因为在运行的时候是直接获取的，根本不需要再去进行额外的运算。也就是在讨论性能的时候，不要鉴定认为什么慢，什么快，而是要讲究场景的变化。

### 1.1.4 补充一个例子

```java
package JavaTeZhongBing;

public class Chapter1_1 {
    public static void main(String[] args) {
        String a = "a";
        final String c = "a";

        String b = a + "b";
        String d = c + "b";
        String e = getA()+"b";

        String compare = "ab";
        System.out.println(b==compare);
        System.out.println(d==compare);
        System.out.println(e==compare);
    }

    private static String getA() {
        return "a";
    }
}

```

其输出是：

```java
false
true
false
```

下面解释原因：

**第一个输出false**:

第一个是 b 和 “ab”比较。虽然我们在代码之中看到了整体而言，a的值是不变的。但是由于其并没有用final 修饰，其是可以被改变的。再加上“字节码增强”技术，当代码切入之后，就可能发生改变。所以编译器不可以对其做优化，此时的 + 操作会被变为类似于 `StringBuilder.append` 的操作。

**第二个输出true**:

由于 c 的前面有 final 修饰，所以可以认为是不变的量，会在编译阶段被优化。

**第三个输出false:**
有两点可以解释：一个是此处的 e 的值有一部分是从 `getA()`拿到的，而`getA()` 是一个函数，编译器在这个阶段不会去方法内部看看其到底做了什么，因为有可能其是一个递归函数，而递归的深度是不可预测的，哪怕经过了递归，也不能断定其一定返回一个常量，这就造成了无意义的资源消耗。

第二点是就算函数最后返回的是一个常量，那么对常量的引用也肯定是通过实现一份拷贝返回的，这份拷贝却不是final的。

### 1.1.5 跟 String 较上劲了

先上一段代码：

```java
package JavaTeZhongBing;

public class Chapter1_1 {
    public static void main(String[] args) {
        String a = "a";
        String b = a + "b";
        String c = "ab";
        String d = new String(b);
        System.out.println(b == c);
        System.out.println(c == d);
        System.out.println(c == d.intern());
        System.out.println(b.intern() == d.intern());
    }
}

```

其返回值是：

```java
false
false
true
true
```

其类似的地方就不再次解释了，那么后面的两个`true` 是因为什么原因呢？

其使用了`intern` 方法，事实上也是因为这个方法才有这样的结果。

`intern`方法相当于是制造了一个常量池，当调用这个方法时，JVM会在这个常量池之中用`equals()`方法找到相同的 String，如果存在的话就直接把这个String的地址返回。没有找到的话，会创建等值的字符串，也就是 char[] ，然后再返回这个新创建空间的地址。

那么只要是同样的字符串，调用`intern` 方法的时候，都会得到常量池之中`String` 的引用，所以两个字符串通过`intern`之后是可以匹配的。

### 1.1.6 intern() / equals()

先贴一下 equals 的代码：

```java
   /**
     * Compares this string to the specified object.  The result is {@code
     * true} if and only if the argument is not {@code null} and is a {@code
     * String} object that represents the same sequence of characters as this
     * object.
     *
     * @param  anObject
     *         The object to compare this {@code String} against
     *
     * @return  {@code true} if the given object represents a {@code String}
     *          equivalent to this string, {@code false} otherwise
     *
     * @see  #compareTo(String)
     * @see  #equalsIgnoreCase(String)
     */
    public boolean equals(Object anObject) {
        if (this == anObject) {
            return true;
        }
        if (anObject instanceof String) {
            String anotherString = (String)anObject;
            int n = value.length;
            if (n == anotherString.value.length) {
                char v1[] = value;
                char v2[] = anotherString.value;
                int i = 0;
                while (n-- != 0) {
                    if (v1[i] != v2[i])
                        return false;
                    i++;
                }
                return true;
            }
        }
        return false;
    }
```

可以看到其分为下面几个步骤：

1. 比较这两个对象是否是同一个对象，如果是的话就直接返回true。
2. 判定传入对象的类型是不是String，不是的话就直接返回 false。
3. 比较两个对象的长度是否是一致的，不一致的话直接返回 false。
4. 循环对比两个字符串的 char[] 数组，逐个对比是否一致。不一致的话直接返回false。
5. 循环结束都没找到不匹配的，最后返回 true。

下面说一下 `intern` 方法：

intern 在常量池之中，需要挨个对比其值是否相同，也就是逐个调用 equals 方法。而且其需要“保证唯一”，那么需要有锁的介入，效率自然大打折扣。因此，直接使用 intern 对比的效率比 equals 的效率低。但是这并不是说 对比地址 比 equals 要慢一些，其是输在了**对比地址之前要先找到地址这个过程上**。

这并不说明 Intern 一无是处。一个方法被设计出来，一定是有其在工程方面的优势。下面我们思考这样一个场景：

在某些设计的时候需要涉及到很多种数据类型，比如 int， double 等等。那么在管理数据类型的时候，很一般会将其以字符串的形式进行存储。如果在这些数据类型之间进行转换，那么首先要对其进行判断。如果使用循环 equals 方法来获得是否相同，会造成不断的循环，效率很差。

但是这种情况下可以使用 intern 方法。在加载数据类型字典的时候直接就 intern 到内存之中，那么在比较的时候就是 “常量比常量”，对比地址，这样就快速多了。

### 1.1.7 StringBuilder.append() 和 String "+" 的 PK

之前在编程的过程中，我们应该都试过使用上千次循环加一个计时器来比较二者之间的性能差别，然后得出`append()` 方法比`+` 更好的结论。下面是对这个过程进行详细的剖析和解释，并且驳斥这个比较的方法，得出比较真实的二者性能差距。

**首先我们分析 + 操作**

分两种情况：

1. 都是常量，那么会像之前提到过的“编译时优化”，直接得到结果。
2. 是运行时拼接，这也是我们下面要仔细剖析的一种情况。

如果是运行时拼接，那么其相当于将代码进行下面这种变化：

原始代码:

```java
				String a = "a";
        String b = "b";
        String c = a + b + "f";
```

经过编译后：

```java
        String a = "a";
        String b = "b";
        StringBuilder temp = new StringBuilder();
        temp.append(a).append(b).append("f");
        String c = temp.toString();
```

注意，此处实际的场景之中会是 class 文件之中的内容，并不是 java 代码。

如果将String 的 + 操作放在循环之中，那么自然的，在循环体内部就会生成许多的 `StringBuilder` 对象，并且在执行 `append()` 之后再调用 `toString()` 生成一个新的 String 对象。每一个循环都会生成这些对象，这些临时对象会占用大量的内存空间，造成频繁的 GC。

![image-20200228163823889](/img/image-20200228163823889.png)

在这个循环过程之中，a 所指向的字符串肯定越来越大，这就意味着垃圾空间越来越大。当这个 a 所指向的字符串达到一定程度之后，肯定会进入Old区域，若所占用的空间达到Old的 1/4， 需要再次分配空间的时候，就可能发生 OOM（Out of Memory），为何是 1/4？先看看 StringBuilder 做了什么。

在循环开始的时候，StringBuilder进行初始化，会先分配一个 StringBuilder对象，这个对象会分配16个长度的 char[] 数组，当发生 append() 操作的时候，如果空间足够，就会继续向后添加元素。

如果空间不够，那么会尝试扩展空间，StringBuilder 扩展的规则是：“基于当前StringBuilder 的 count 值+ 传入字符串的长度”来作为新的 char[] 的参考值。然后将这个参考值和StringBuilder 的 char[] 的长度的2倍来取最大值，也就是其最少也会扩展到原来长度的2倍。

> count 值并不是 char[] 的总长度，而是当前 StringBuilder 之中有效元素的个数，或者可以说是 `StringBuilder.length()` 的值。char[] 数组的总长度可以通过 `capacity()`得到

 ![image-20200228170808297](/img/image-20200228170808297.png)

那么结合之前说的“循环扩展字符串”，每次扩容最少会扩容2倍。再加上此时的扩容前对象还需要保留，在某些时间点上面需要的是3倍的内存空间，自然 JVM 的 Young 空间的 Suvivor 区域会很快就装不下，要让其进入 Old 区域。

**下面讲一下是为何如果一个对象占用 1/4 的空间就有可能发生 OOM：**

当 a 所引用的对象占用了 Old 区域的 1/4 空间时，同样会先分配一个 StringBuilder 的对象，初始化的长度还是 16 个长度的 char[] 数组。按照上面的步骤，首先StringBuffer 会先进行append a 的操作，那么按照要么长度加倍要么 count+相应长度，我们选择后者，可以得到其需要占用 1/4 的长度。则目前就已经占用了 1/2 的 Old 空间。

不要忘了我们后面还有 append 随机字符的操作。如果这个随机字符串不是 “”， 那么在这次随机append的时候当前的StringBuilder已经满了，其需要扩容，按照之前的标准，要取原来长度的2倍，则 Old 空间之中仅存的 1/2 空间也被占用了。此时内存直接“撑死”。

> 释放空间的前提是数据已经拷贝过来。当我们分配一个2倍大小的空间时，数据还没拷贝，所以这个空间就没法释放。

![2020.02.28_17.26.59](/img/2020.02.28_17.26.59.jpg)

这里的假设还是所有的 JVM 内存都用来给一个 String，但是在实际生产过程之中这种情况近乎不可能，所以其 OOM 的概率肯定会更高。

我们上面说完了 + 操作，那再回头看看 StringBuilder 是怎么做的？

```java
 StringBuilder builder = new StringBuilder();
        for(...){
            builder.append(random string)
        }
```

注意，在这个过程之中，并没有任何的新StringBuilder 对象被产生，其扩容的时候始终是2倍扩容，且每次扩容之后都近乎有一半空间是空闲的，其为扩容之前数组的大小（由于每次都 append 一个随机的字符）。

且因祸得福，对象空间越大，扩容的空间也越大，那么越不会进行再次扩容。更不会像之前的例子之中，每次都要新建一个巨大的 StringBuilder，并且很快将其GC，甚至对这个超大的 StringBuilder 做扩容操作。

这种情况之下，只有当其所占的内存区域接近于 Old 区域的 1/3 的时候进行扩容会发生OOM（原始长度1/3，扩容之后的新StringBuilder 是 2/3）。并且，在 StringBuilder.append 过程之中的垃圾内存大部分都是小块的内存，产生的垃圾就是拼接的对象和扩容时候的原来的空间；相对比之下，下一次再发生的 + 操作时，前一次 + 操作的结果就成了垃圾内存，自然垃圾就越来越多，且内在扩容会产生更多的垃圾。

