---
layout:     post   				    # 使用的布局（不需要改）
title:      《Java特种兵》阅读笔记  		# 标题 
subtitle:   第一篇——Java功底篇       #副标题
date:       2020-02-27		# 时间
author:     Haiming 						# 作者
header-img: img/post-bg-2015.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - 编程
    - Java
---

开干。

# 第一章：看看功底如何

## 1.1 String的例子，见证下功底

下面看看 `equals()` 怎么用：

```java
package JavaTeZhongBing;

public class Chapter1_1 {
    public static void main(String[] args) {
        String a = "a" + "b" + 1;
        String b = "ab1";
        System.out.println(a == b);
    }
}

```

按照之前的想法，是不是a和b两个对象使用`equals()` 结果为false嘛。

结果为`true`。

为什么呢？

要弄清楚以下4点：

1. `==`是做什么的？
2. `equals`是做什么的？
3. a和b在内存之中是如何安排的？
4. 编译时优化的方案

### 1.1.1 关于 `==`

`==`比较内存单元的内容，其实比较的就是一个数字。

在 Java 之中，`==`来匹配的就是两个内存单元的内容是否相同。

分情况：

1. 如果是原始类型，直接比较其值
2. 如果是引用(reference)，比较的是引用的值，其可以被理解为对象的“逻辑地址”。

### 1.1.2 关于 `equals()`

`eqauls()`方法，首先在 Object 之中被定义。

```java
    public boolean equals(Object obj) {
        return (this == obj);
    }
```

可见对于对象，其原始定义之中就是比较对象的地址。

那么这个方法存在的意义是什么呢？就是希望子类可以重写这个方法，实现个性化的对比的功能。比如在String 之中就重写了 `equals()`方法：

```java
   public boolean equals(Object anObject) {
        if (this == anObject) {
            return true;
        }
        if (anObject instanceof String) {
            String anotherString = (String)anObject;
            int n = value.length;
            if (n == anotherString.value.length) {
                char v1[] = value;
                char v2[] = anotherString.value;
                int i = 0;
                while (n-- != 0) {
                    if (v1[i] != v2[i])
                        return false;
                    i++;
                }
                return true;
            }
        }
        return false;
    }
```

提供个性化的`equals()`表达方法，是为了适应多种业务的个性化满足。换句话，如果你想，可以直接强制这个方法返回true，那么比较之后就是和所有参数都相等了。

有的人会问，那`hashCode()` 是不是也需要重写一下呢？

这里有一个概念辨析：有人会认为 `hashCode()` 也是用来标识一个对象。这是大错特错。

`hashCode()`是一个 native 方法，本身返回值默认和`System.identityHashCode(object)`一致。在通常情况下，值是对象头部的一部分二进制位组成的数字，**其虽然具有一定的标识对象的意义**，但是绝对**不等价于地址**，**也绝对不保证没有冲突**。

`hashCode()`的作用，**是产生一个可以标识对象的数字**。这个数字在什么时候需要呢？比如在`HashSet`,`HashMap`之中，基于对象本身产生 key，就可以使用。

`hashCode` 只能说是标识对象，因此在Hash算法之中可以讲对象相对离散开。但是并不是说`hashCode()`值是唯一的，所以在Hash算法之中定位到具体链表后，需要进一步循环链表，然后通过`equals()`来对比值是不是一致的。

换句话，`hashCode()`是用来快速定位数据，而`equals()`是用来对比真实值。

**下面就`hashCode()`和`equals()` 两者之间的资源消耗做一个比较：**

拿String来说，其至少会在第一次调用 hashCode() 方法的时候**遍历所有char[] 数组并且计算hashCode值**，所以两个String进行比较至少会遍历两次char[],如果在期间遇到了并发使用hashCode()的情况，可能还会多很多次调用。可是即使耗费了这么多资源，也依旧是没法确定两个对象相等（前面讲过两个完全不同的对象 hashCode 有可能相同。

但是equals的内部是可以自己去设计逻辑，包括可以先从简单的东西还是比较再到比较复杂的结构，或者先对比地址，长度等等方式将不匹配的东西尽快排除。

