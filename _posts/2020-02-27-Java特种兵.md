---
layout:     post   				    # 使用的布局（不需要改）
title:      《Java特种兵》阅读笔记  		# 标题 
subtitle:   第一篇——Java功底篇       #副标题
date:       2020-02-27		# 时间
author:     Haiming 						# 作者
header-img: img/post-bg-2015.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - 编程
    - Java
---

开干。

# 第一章：看看功底如何

## 1.1 String的例子，见证下功底

下面看看 `equals()` 怎么用：

```java
package JavaTeZhongBing;

public class Chapter1_1 {
    public static void main(String[] args) {
        String a = "a" + "b" + 1;
        String b = "ab1";
        System.out.println(a == b);
    }
}

```

按照之前的想法，是不是a和b两个对象使用`equals()` 结果为false嘛。

结果为`true`。

为什么呢？

要弄清楚以下4点：

1. `==`是做什么的？
2. `equals`是做什么的？
3. a和b在内存之中是如何安排的？
4. 编译时优化的方案

### 1.1.1 关于 `==`

`==`比较内存单元的内容，其实比较的就是一个数字。

在 Java 之中，`==`来匹配的就是两个内存单元的内容是否相同。

分情况：

1. 如果是原始类型，直接比较其值
2. 如果是引用(reference)，比较的是引用的值，其可以被理解为对象的“逻辑地址”。

### 1.1.2 关于 `equals()`

`eqauls()`方法，首先在 Object 之中被定义。

```java
    public boolean equals(Object obj) {
        return (this == obj);
    }
```

可见对于对象，其原始定义之中就是比较对象的地址。

那么这个方法存在的意义是什么呢？就是希望子类可以重写这个方法，实现个性化的对比的功能。比如在String 之中就重写了 `equals()`方法：

```java
   public boolean equals(Object anObject) {
        if (this == anObject) {
            return true;
        }
        if (anObject instanceof String) {
            String anotherString = (String)anObject;
            int n = value.length;
            if (n == anotherString.value.length) {
                char v1[] = value;
                char v2[] = anotherString.value;
                int i = 0;
                while (n-- != 0) {
                    if (v1[i] != v2[i])
                        return false;
                    i++;
                }
                return true;
            }
        }
        return false;
    }
```

提供个性化的`equals()`表达方法，是为了适应多种业务的个性化满足。换句话，如果你想，可以直接强制这个方法返回true，那么比较之后就是和所有参数都相等了。

有的人会问，那`hashCode()` 是不是也需要重写一下呢？

这里有一个概念辨析：有人会认为 `hashCode()` 也是用来标识一个对象。这是大错特错。

`hashCode()`是一个 native 方法，本身返回值默认和`System.identityHashCode(object)`一致。在通常情况下，值是对象头部的一部分二进制位组成的数字，**其虽然具有一定的标识对象的意义**，但是绝对**不等价于地址**，**也绝对不保证没有冲突**。

`hashCode()`的作用，**是产生一个可以标识对象的数字**。这个数字在什么时候需要呢？比如在`HashSet`,`HashMap`之中，基于对象本身产生 key，就可以使用。

`hashCode` 只能说是标识对象，因此在Hash算法之中可以讲对象相对离散开。但是并不是说`hashCode()`值是唯一的，所以在Hash算法之中定位到具体链表后，需要进一步循环链表，然后通过`equals()`来对比值是不是一致的。

换句话，`hashCode()`是用来快速定位数据，而`equals()`是用来对比真实值。

**下面就`hashCode()`和`equals()` 两者之间的资源消耗做一个比较：**

拿String来说，其至少会在第一次调用 hashCode() 方法的时候**遍历所有char[] 数组并且计算hashCode值**，所以两个String进行比较至少会遍历两次char[],如果在期间遇到了并发使用hashCode()的情况，可能还会多很多次调用。可是即使耗费了这么多资源，也依旧是没法确定两个对象相等（前面讲过两个完全不同的对象 hashCode 有可能相同。

但是equals的内部是可以自己去设计逻辑，包括可以先从简单的东西还是比较再到比较复杂的结构，或者先对比地址，长度等等方式将不匹配的东西尽快排除。

### 1.1.3 编译时优化方案

为什么a引用是通过 + 操作来获得对象，b是直接赋值的对象，看起来完全是两个引用，但是最终其指向的是一个内存单元呢？这就是 JVM 之中的“编译时优化”。

是因为编译器在编译代码的时候，就会将`"a"+"b"+1` 作为`"ab1”`。原因是这三个值都是常量，在编译器编译的时候会认为这几个值在程序运行的过程之中也会保持不变，所以无需运行时再计算，就会这样优化。

为了提高效率和节约资源，能提前做的事情编译器就有可能会提前做。但是 JVM 只会优化其可以优化的部分，如果在上面的字符串之中出现了变量，那么就不会在编译阶段进行优化。

**注意：只要JVM不能确定的情况，比如变量这种，JVM一定不会优化。但绝对不代表只要是常量JVM就会提前进行优化。**

小Tip：这也证明了实际上"+" 操作**不一定**比`StringBuilder.append()`慢，如果是编译时合并那么就会更快，因为在运行的时候是直接获取的，根本不需要再去进行额外的运算。也就是在讨论性能的时候，不要鉴定认为什么慢，什么快，而是要讲究场景的变化。

### 1.1.4 补充一个例子

```java
package JavaTeZhongBing;

public class Chapter1_1 {
    public static void main(String[] args) {
        String a = "a";
        final String c = "a";

        String b = a + "b";
        String d = c + "b";
        String e = getA()+"b";

        String compare = "ab";
        System.out.println(b==compare);
        System.out.println(d==compare);
        System.out.println(e==compare);
    }

    private static String getA() {
        return "a";
    }
}

```

其输出是：

```java
false
true
false
```

下面解释原因：

**第一个输出false**:

第一个是 b 和 “ab”比较。虽然我们在代码之中看到了整体而言，a的值是不变的。但是由于其并没有用final 修饰，其是可以被改变的。再加上“字节码增强”技术，当代码切入之后，就可能发生改变。所以编译器不可以对其做优化，此时的 + 操作会被变为类似于 `StringBuilder.append` 的操作。

**第二个输出true**:

由于 c 的前面有 final 修饰，所以可以认为是不变的量，会在编译阶段被优化。

**第三个输出false:**
有两点可以解释：一个是此处的 e 的值有一部分是从 `getA()`拿到的，而`getA()` 是一个函数，编译器在这个阶段不会去方法内部看看其到底做了什么，因为有可能其是一个递归函数，而递归的深度是不可预测的，哪怕经过了递归，也不能断定其一定返回一个常量，这就造成了无意义的资源消耗。

第二点是就算函数最后返回的是一个常量，那么对常量的引用也肯定是通过实现一份拷贝返回的，这份拷贝却不是final的。

### 1.1.5 跟 String 较上劲了

先上一段代码：

```java
package JavaTeZhongBing;

public class Chapter1_1 {
    public static void main(String[] args) {
        String a = "a";
        String b = a + "b";
        String c = "ab";
        String d = new String(b);
        System.out.println(b == c);
        System.out.println(c == d);
        System.out.println(c == d.intern());
        System.out.println(b.intern() == d.intern());
    }
}

```

其返回值是：

```java
false
false
true
true
```

其类似的地方就不再次解释了，那么后面的两个`true` 是因为什么原因呢？

其使用了`intern` 方法，事实上也是因为这个方法才有这样的结果。

`intern`方法相当于是制造了一个常量池，当调用这个方法时，JVM会在这个常量池之中用`equals()`方法找到相同的 String，如果存在的话就直接把这个String的地址返回。没有找到的话，会创建等值的字符串，也就是 char[] ，然后再返回这个新创建空间的地址。

那么只要是同样的字符串，调用`intern` 方法的时候，都会得到常量池之中`String` 的引用，所以两个字符串通过`intern`之后是可以匹配的。

### 1.1.6 intern() / equals()

先贴一下 equals 的代码：

```java
   /**
     * Compares this string to the specified object.  The result is {@code
     * true} if and only if the argument is not {@code null} and is a {@code
     * String} object that represents the same sequence of characters as this
     * object.
     *
     * @param  anObject
     *         The object to compare this {@code String} against
     *
     * @return  {@code true} if the given object represents a {@code String}
     *          equivalent to this string, {@code false} otherwise
     *
     * @see  #compareTo(String)
     * @see  #equalsIgnoreCase(String)
     */
    public boolean equals(Object anObject) {
        if (this == anObject) {
            return true;
        }
        if (anObject instanceof String) {
            String anotherString = (String)anObject;
            int n = value.length;
            if (n == anotherString.value.length) {
                char v1[] = value;
                char v2[] = anotherString.value;
                int i = 0;
                while (n-- != 0) {
                    if (v1[i] != v2[i])
                        return false;
                    i++;
                }
                return true;
            }
        }
        return false;
    }
```

可以看到其分为下面几个步骤：

1. 比较这两个对象是否是同一个对象，如果是的话就直接返回true。
2. 判定传入对象的类型是不是String，不是的话就直接返回 false。
3. 比较两个对象的长度是否是一致的，不一致的话直接返回 false。
4. 循环对比两个字符串的 char[] 数组，逐个对比是否一致。不一致的话直接返回false。
5. 循环结束都没找到不匹配的，最后返回 true。

下面说一下 `intern` 方法：

