---
layout:     post   				    # 使用的布局（不需要改）
title:      RocketMQ初步总结和辨析  		# 标题 
subtitle:   消息队列和RocketMQ入门总结        #副标题
date:       2020-02-17		# 时间
author:     Haiming 						# 作者
header-img: img/post-bg-2015.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - 编程
    - RocketMQ
    - MQ
---

看到一篇文章之中对消息队列和RocketMQ做了初步的总结，觉得比较好，在此加上自己对于部分功能的解释在这里写一篇。

原文链接：https://juejin.im/post/5df0825b51882512420af94a

参考链接：https://www.cnblogs.com/chjxbt/p/11407890.html

# 消息队列简介

对于消息队列，之前有过梳理，此处只是对之前叙述不够完善和不够详细的地方做一些补充。

### 消息队列为什么会出现？

**分布式应用必定涉及到各个系统之间的通信问题，因为分布式应用必定涉及到各个系统之间的通信问题。**可以说分布式是消息队列的基础，也是消息队列产生的土壤。

### 消息队列可以用来干嘛？

异步需求，削峰填谷，系统解耦

### 消息队列有什么副作用？

- 降低系统可用性
- 增加系统复杂度
- 重复消费的问题
- 顺序消费的问题：有些消息天然是具有顺序性的，比如对某条记录进行删除增加修改三种操作，但是在发布订阅模型之中，主题是没有顺序的，那么这个时候就会导致消费者使用信息的顺序修改。
- 分布式事务问题：不像在单个系统之中，例如在Spring之中加入`@Transactional`即可，但是在不同的系统之中如何保证事务呢？
- 消息堆积的问题：如果消息的产生速率非常高，但是与此同时其消费速率又很低，那么会产生消息堆积的问题，当其数量足够多的时候，会将消息堆积在消息队列之中。

# 队列模型和主题模型

### 队列模型

消息中间件的队列模型真的就只是一个队列，如下图所示：

![img](../img/16ef3834ae653469.jpeg)

一开始有一个“广播”的概念，那么这个单个队列的模型就远远不能满足需求了，当然可以让Producer生产消息放入多个队列之中，然后每一个队列对应一个消费者。

创建队列并且赋值多个消息是非常浪费性能的，这甚至需要生产者需要具体知道消费者的数量，并且复制对应数量的消息队列。创建消息队列和复制消息队列是很影响资源和性能的。

而且这种情况下会导致生产者知道具体的消费者个数，并且根据个数去复制对应数量的消息队列，这就违背了**解耦**这一原则。

如果多个消费者对应一个队列的消息，那么其实他们是竞争关系，每个消费者只能收到队列之中的一部分信息，也就是**一条消息只能被一个消费者收到**。

### 主题模型

如何解决这一问题？就是使用**主题模型**或者**发布——订阅模型**。

在主题模型之中，消息的生产者被称为**发布者**，消息的消费者称为**订阅者**，存放消息的容器称为**主题**。

![img](../img/16ef3837887d9a54.jpeg)

### 对比

对比这两种模型，其本质并没有区别，主要是**一份数据是否可以被消费多次**的问题。如果只有一个订阅者，那么其和队列模型就基本相同了，也就是说，发布——订阅模型是兼容队列模型的。

# RabbitMQ和RocketMQ

### RabbitMQ的消息模型

RabbitMQ还是坚持使用队列模型，使用Exchange模块解决多个消费者的问题，Exchange模块位于生产者和队列之间，**生产者**并不关心将消息发到哪个队列，而是将消息发送给**Exchange**，由 Exchange上面配置的策略来决定将消息投递到哪些队列之中。

![img](../img/1513968-20190825145306466-1941619714.jpg)

同一个消息如果想被多个消费者消费，那么其需要配置Exchange将消息发送到多个队列，每个队列之中都存放一份完整的消息数据，可以为**一个**消费者提供消费服务。

### RocketMQ的消息模型

RockerMQ使用的消息模型是标准的**发布——订阅**模型，但是其中也有队列(queue)这个概念。

**消息队列的消费机制：**

几乎所有的消息队列产品都会使用一种非常朴素的“请求——确认”机制来确保其在传输过程之中不会消失。

这种确认机制很好的保证了信息传递之中的可靠性。但是随之而来的也有了新的问题：**为了确保消息的有序性，在某一条消息被成功消费之前，下一条消息不能被消费**。也就是说，每个主题在任意时刻，都只能有最多一个消费者来进行消费。（需要等待一个消费者取完信息才可以完成“确认——请求”的步骤）

为了解决此问题，RocketMQ在主题下面增加了队列的概念：

![img](../img/1513968-20190825151749079-2100411321.jpg)

- 每个主题之中包含多个队列，且RocketMQ在主题层面上面无法保证消息的严格顺序。
- 生产者会对所有队列发消息，但是**一条消息只会向某个队列之中发送一次**
- **针对一个消费组**，