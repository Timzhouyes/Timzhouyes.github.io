---
layout:     post   				    # 使用的布局（不需要改）
title:      《Java特种兵》阅读笔记(3)  		# 标题 
subtitle:    第三章-JVM，Java程序员的OS       #副标题
date:       2020-03-12		# 时间
author:     Haiming 						# 作者
header-img: img/post-bg-2015.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - 编程
    - Java
---

# 第三章 - JVM，Java程序员的OS

## 3.2 跨平台和字节码基本原理

### 3.2.1 javap 命令工具

```java
public class StringTest {
    public static void main(String[] args) {
        String a = "a" + "b" + 1;
        String b = "ab1";
        System.out.println(a == b);
    }
}
```

上面这段代码先经过 `javac -g:vars StringTest.java` 之后再使用 `javap -verbose StringTest    `， 来使用这里的命令来论证我们之前提到过的结论。

```java
  Last modified 12 Mar, 2020; size 609 bytes
  MD5 checksum 72c295fac93103d4c254971bd5a25a19
public class JavaTeZhongBing.StringTest
  minor version: 0
  major version: 52
  flags: ACC_PUBLIC, ACC_SUPER
Constant pool:
   #1 = Methodref          #6.#24         // java/lang/Object."<init>":()V
   #2 = String             #25            // ab1
   #3 = Fieldref           #26.#27        // java/lang/System.out:Ljava/io/PrintStream;
   #4 = Methodref          #28.#29        // java/io/PrintStream.println:(Z)V
   #5 = Class              #30            // JavaTeZhongBing/StringTest
   #6 = Class              #31            // java/lang/Object
   #7 = Utf8               <init>
   #8 = Utf8               ()V
   #9 = Utf8               Code
  #10 = Utf8               LocalVariableTable
  #11 = Utf8               this
  #12 = Utf8               LJavaTeZhongBing/StringTest;
  #13 = Utf8               main
  #14 = Utf8               ([Ljava/lang/String;)V
  #15 = Utf8               args
  #16 = Utf8               [Ljava/lang/String;
  #17 = Utf8               a
  #18 = Utf8               Ljava/lang/String;
  #19 = Utf8               b
  #20 = Utf8               StackMapTable
  #21 = Class              #16            // "[Ljava/lang/String;"
  #22 = Class              #32            // java/lang/String
  #23 = Class              #33            // java/io/PrintStream
  #24 = NameAndType        #7:#8          // "<init>":()V
  #25 = Utf8               ab1
  #26 = Class              #34            // java/lang/System
  #27 = NameAndType        #35:#36        // out:Ljava/io/PrintStream;
  #28 = Class              #33            // java/io/PrintStream
  #29 = NameAndType        #37:#38        // println:(Z)V
  #30 = Utf8               JavaTeZhongBing/StringTest
  #31 = Utf8               java/lang/Object
  #32 = Utf8               java/lang/String
  #33 = Utf8               java/io/PrintStream
  #34 = Utf8               java/lang/System
  #35 = Utf8               out
  #36 = Utf8               Ljava/io/PrintStream;
  #37 = Utf8               println
  #38 = Utf8               (Z)V
{
  public JavaTeZhongBing.StringTest();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object."<init>":()V
         4: return
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       5     0  this   LJavaTeZhongBing/StringTest;

  public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=3, locals=3, args_size=1
         0: ldc           #2                  // String ab1
         2: astore_1
         3: ldc           #2                  // String ab1
         5: astore_2
         6: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;
         9: aload_1
        10: aload_2
        11: if_acmpne     18
        14: iconst_1
        15: goto          19
        18: iconst_0
        19: invokevirtual #4                  // Method java/io/PrintStream.println:(Z)V
        22: return
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      23     0  args   [Ljava/lang/String;
            3      20     1     a   Ljava/lang/String;
            6      17     2     b   Ljava/lang/String;
      StackMapTable: number_of_entries = 2
        frame_type = 255 /* full_frame */
          offset_delta = 18
          locals = [ class "[Ljava/lang/String;", class java/lang/String, class java/lang/String ]
          stack = [ class java/io/PrintStream ]
        frame_type = 255 /* full_frame */
          offset_delta = 0
          locals = [ class "[Ljava/lang/String;", class java/lang/String, class java/lang/String ]
          stack = [ class java/io/PrintStream, int ]
}



```

还是一样解析：

开头的一部分是常量池，每一项的开头都是 `const #数字`，这个数字是顺序递增的，通常叫做入口位置。根据入口位置找某些常量内容，常量内容分为很多种。每个常量池项最前面的一个字节，用来表示常量的类型（我们所看到的后面的备注，比如Method，Class等等，都是映射转化之后得到的，字节码之中只有一个字节来存放）。

接下来是内容，内容可以直接存放在常量池的入口，也可能由其他的一个或者几个常量池域组合而成。下面讲几个例子：

**例子1：**

`   #1 = Methodref          #6.#24         // java/lang/Object."<init>":()V`

入口#1，代表一个方法入口，方法入口由 #6 和 #24 组成，中间用了一个 . 分割。

`   #6 = Class              #31            // java/lang/Object`

`  #24 = NameAndType        #7:#8          // "<init>":()V`

入口 #6，是一个class，class是一个引用，所以其引用了 #31 的常量池。

入口 #21 代表一个表示名称和类型(NameAndType)，分别由入口 #7 和 入口#8组成。

`   #7 = Utf8               <init>`

`#8 = Utf8               ()V`

`  #31 = Utf8               java/lang/Object`

入口#7 是一个常量池内容 `<init>`，代表构造方法。

入口 #8 是一个真正的常量，值是  ()V ，其没有入口参数，所以返回值是 void。将入口 #7,#8 反推到入口 #24,就代表这个构造方法的名称，入口参数的个数为0，返回值是 void。

入口#28是一个常量，其值为`java/lang/Object`，但是这个只是一个字符串，反推到#6，就要求这个字符串代表一个类，那么可以推得其代表的类是`java,lang.Object`。

那么将这三部分统一起来，其代表的就是 java.lang.Object 类型的构造方法，入口参数的个数为0，返回值为 void。注意，这部分实际在 const#1 之后的备注已经表示出来了（这部分备注在字节码之中并不存在，只是 javap 工具帮助合并的）。

**例子2：**

`   #2 = String             #25            // ab1`

代表将会有一个String类型的引用入口，而引用的都是入口#22的内容。

`  #25 = Utf8               ab1`

代表常量池之中会存放内容 ab1.

那么上面二者综合起来就是：一个String对象的常量，存放的值是 ab1.

**例子3：**

`   #3 = Fieldref           #26.#27        // java/lang/System.out:Ljava/io/PrintStream;`

`   #4 = Methodref          #28.#29        // java/io/PrintStream.println:(Z)V`

入口#3代表一个属性，这个属性引用了入口#26的类，入口#27的**具体属性**。

入口#4代表一个方法，引用了入口#28的类，#29 的**具体方法**。

```java
  #26 = Class              #34            // java/lang/System
  #27 = NameAndType        #35:#36        // out:Ljava/io/PrintStream;
  #28 = Class              #33            // java/io/PrintStream
  #29 = NameAndType        #37:#38        // println:(Z)V
```

入口 #26代表一个 class，其也是一个引用，引用了入口#34的常量。

入口 #27 代表名称和类型（NameAndType），其对应入口 #35， #36

入口 #28 引用入口 #30

入口 #29 代表名称和类型，也是一个返回值+引用类型。对应入口 #37. #38。

```java
  #33 = Utf8               java/io/PrintStream
  #34 = Utf8               java/lang/System
  #35 = Utf8               out
  #36 = Utf8               Ljava/io/PrintStream;
  #37 = Utf8               println
  #38 = Utf8               (Z)V
```

入口 #33 对应的常量池是 `java/io/PrintStream`。反推到入口 #28，代表类`java.lang.PrintStream`。

入口 #34 对应的常量是 `java/lang/System`，反推到入口 #26，代表类`java.lang.System`。

入口 #35 对应的常量池是 out ,反推到入口 #27，而入口#27 要求名称和类型，此处明显是返回的名称。

入口 #36 对应是`Ljava/io/PrintStream;`， 反推到入口 #27，已经知道其要求的是名称和类型了，那么此处明显返回的是类型，也就是 out 的类型是  `java.io.PrintStream`。

入口 #37 对应的是 println，反推到入口 #29， 其需要名称和类型，那么此处返回的是名称，其名称为 println

入口 #38 对应的是 `(Z)V`，反推到入口#29， 可得此处返回的是类型，即代表入口参数为Z(代表boolean)，返回参数为V(void)。

那么将这些综合起来，就可以知道其要执行的操作为：

入口 #3是获取到 java/lang/System 类的属性 out，其 out 的类型是 Ljava/io/PrintStream;

入口 #4 是获取到 java/io/PrintStream 类的 println 方法，方法的返回值是 void，入口的类型是 boolean。

