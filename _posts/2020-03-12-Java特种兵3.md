---
layout:     post   				    # 使用的布局（不需要改）
title:      《Java特种兵》阅读笔记(3)  		# 标题 
subtitle:    第三章-JVM，Java程序员的OS       #副标题
date:       2020-03-12		# 时间
author:     Haiming 						# 作者
header-img: img/post-bg-2015.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - 编程
    - Java
---

# 第三章 - JVM，Java程序员的OS

## 3.2 跨平台和字节码基本原理

### 3.2.1 javap 命令工具

```java
public class StringTest {
    public static void main(String[] args) {
        String a = "a" + "b" + 1;
        String b = "ab1";
        System.out.println(a == b);
    }
}
```

上面这段代码先经过 `javac -g:vars StringTest.java` 之后再使用 `javap -verbose StringTest    `， 来使用这里的命令来论证我们之前提到过的结论。

```java
  Last modified 12 Mar, 2020; size 609 bytes
  MD5 checksum 72c295fac93103d4c254971bd5a25a19
public class JavaTeZhongBing.StringTest
  minor version: 0
  major version: 52
  flags: ACC_PUBLIC, ACC_SUPER
Constant pool:
   #1 = Methodref          #6.#24         // java/lang/Object."<init>":()V
   #2 = String             #25            // ab1
   #3 = Fieldref           #26.#27        // java/lang/System.out:Ljava/io/PrintStream;
   #4 = Methodref          #28.#29        // java/io/PrintStream.println:(Z)V
   #5 = Class              #30            // JavaTeZhongBing/StringTest
   #6 = Class              #31            // java/lang/Object
   #7 = Utf8               <init>
   #8 = Utf8               ()V
   #9 = Utf8               Code
  #10 = Utf8               LocalVariableTable
  #11 = Utf8               this
  #12 = Utf8               LJavaTeZhongBing/StringTest;
  #13 = Utf8               main
  #14 = Utf8               ([Ljava/lang/String;)V
  #15 = Utf8               args
  #16 = Utf8               [Ljava/lang/String;
  #17 = Utf8               a
  #18 = Utf8               Ljava/lang/String;
  #19 = Utf8               b
  #20 = Utf8               StackMapTable
  #21 = Class              #16            // "[Ljava/lang/String;"
  #22 = Class              #32            // java/lang/String
  #23 = Class              #33            // java/io/PrintStream
  #24 = NameAndType        #7:#8          // "<init>":()V
  #25 = Utf8               ab1
  #26 = Class              #34            // java/lang/System
  #27 = NameAndType        #35:#36        // out:Ljava/io/PrintStream;
  #28 = Class              #33            // java/io/PrintStream
  #29 = NameAndType        #37:#38        // println:(Z)V
  #30 = Utf8               JavaTeZhongBing/StringTest
  #31 = Utf8               java/lang/Object
  #32 = Utf8               java/lang/String
  #33 = Utf8               java/io/PrintStream
  #34 = Utf8               java/lang/System
  #35 = Utf8               out
  #36 = Utf8               Ljava/io/PrintStream;
  #37 = Utf8               println
  #38 = Utf8               (Z)V
{
  public JavaTeZhongBing.StringTest();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object."<init>":()V
         4: return
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       5     0  this   LJavaTeZhongBing/StringTest;

  public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=3, locals=3, args_size=1
         0: ldc           #2                  // String ab1
         2: astore_1
         3: ldc           #2                  // String ab1
         5: astore_2
         6: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;
         9: aload_1
        10: aload_2
        11: if_acmpne     18
        14: iconst_1
        15: goto          19
        18: iconst_0
        19: invokevirtual #4                  // Method java/io/PrintStream.println:(Z)V
        22: return
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      23     0  args   [Ljava/lang/String;
            3      20     1     a   Ljava/lang/String;
            6      17     2     b   Ljava/lang/String;
      StackMapTable: number_of_entries = 2
        frame_type = 255 /* full_frame */
          offset_delta = 18
          locals = [ class "[Ljava/lang/String;", class java/lang/String, class java/lang/String ]
          stack = [ class java/io/PrintStream ]
        frame_type = 255 /* full_frame */
          offset_delta = 0
          locals = [ class "[Ljava/lang/String;", class java/lang/String, class java/lang/String ]
          stack = [ class java/io/PrintStream, int ]
}



```

还是一样解析：

开头的一部分是常量池，每一项的开头都是 `const #数字`，这个数字是顺序递增的，通常叫做入口位置。根据入口位置找某些常量内容，常量内容分为很多种。每个常量池项最前面的一个字节，用来表示常量的类型（我们所看到的后面的备注，比如Method，Class等等，都是映射转化之后得到的，字节码之中只有一个字节来存放）。

接下来是内容，内容可以直接存放在常量池的入口，也可能由其他的一个或者几个常量池域组合而成。下面讲几个例子：

**例子1：**

`   #1 = Methodref          #6.#24         // java/lang/Object."<init>":()V`

入口#1，代表一个方法入口，方法入口由 #6 和 #24 组成，中间用了一个 . 分割。

`   #6 = Class              #31            // java/lang/Object`

`  #24 = NameAndType        #7:#8          // "<init>":()V`

入口 #6，是一个class，class是一个引用，所以其引用了 #31 的常量池。

入口 #21 代表一个表示名称和类型(NameAndType)，分别由入口 #7 和 入口#8组成。

`   #7 = Utf8               <init>`

`#8 = Utf8               ()V`

`  #31 = Utf8               java/lang/Object`

入口#7 是一个常量池内容 `<init>`，代表构造方法。

入口 #8 是一个真正的常量，值是  ()V ，其没有入口参数，所以返回值是 void。将入口 #7,#8 反推到入口 #24,就代表这个构造方法的名称，入口参数的个数为0，返回值是 void。

入口#28是一个常量，其值为`java/lang/Object`，但是这个只是一个字符串，反推到#6，就要求这个字符串代表一个类，那么可以推得其代表的类是`java,lang.Object`。

那么将这三部分统一起来，其代表的就是 java.lang.Object 类型的构造方法，入口参数的个数为0，返回值为 void。注意，这部分实际在 const#1 之后的备注已经表示出来了（这部分备注在字节码之中并不存在，只是 javap 工具帮助合并的）。

**例子2：**

`   #2 = String             #25            // ab1`

代表将会有一个String类型的引用入口，而引用的都是入口#22的内容。

`  #25 = Utf8               ab1`

代表常量池之中会存放内容 ab1.

那么上面二者综合起来就是：一个String对象的常量，存放的值是 ab1.

**例子3：**

`   #3 = Fieldref           #26.#27        // java/lang/System.out:Ljava/io/PrintStream;`

`   #4 = Methodref          #28.#29        // java/io/PrintStream.println:(Z)V`

入口#3代表一个属性，这个属性引用了入口#26的类，入口#27的**具体属性**。

入口#4代表一个方法，引用了入口#28的类，#29 的**具体方法**。

```java
  #26 = Class              #34            // java/lang/System
  #27 = NameAndType        #35:#36        // out:Ljava/io/PrintStream;
  #28 = Class              #33            // java/io/PrintStream
  #29 = NameAndType        #37:#38        // println:(Z)V
```

入口 #26代表一个 class，其也是一个引用，引用了入口#34的常量。

入口 #27 代表名称和类型（NameAndType），其对应入口 #35， #36

入口 #28 引用入口 #30

入口 #29 代表名称和类型，也是一个返回值+引用类型。对应入口 #37. #38。

```java
  #33 = Utf8               java/io/PrintStream
  #34 = Utf8               java/lang/System
  #35 = Utf8               out
  #36 = Utf8               Ljava/io/PrintStream;
  #37 = Utf8               println
  #38 = Utf8               (Z)V
```

入口 #33 对应的常量池是 `java/io/PrintStream`。反推到入口 #28，代表类`java.lang.PrintStream`。

入口 #34 对应的常量是 `java/lang/System`，反推到入口 #26，代表类`java.lang.System`。

入口 #35 对应的常量池是 out ,反推到入口 #27，而入口#27 要求名称和类型，此处明显是返回的名称。

入口 #36 对应是`Ljava/io/PrintStream;`， 反推到入口 #27，已经知道其要求的是名称和类型了，那么此处明显返回的是类型，也就是 out 的类型是  `java.io.PrintStream`。

入口 #37 对应的是 println，反推到入口 #29， 其需要名称和类型，那么此处返回的是名称，其名称为 println

入口 #38 对应的是 `(Z)V`，反推到入口#29， 可得此处返回的是类型，即代表入口参数为Z(代表boolean)，返回参数为V(void)。

那么将这些综合起来，就可以知道其要执行的操作为：

入口 #3是获取到 java/lang/System 类的属性 out，其 out 的类型是 Ljava/io/PrintStream;

入口 #4 是获取到 java/io/PrintStream 类的 println 方法，方法的返回值是 void，入口的类型是 boolean。

这个常量池仅仅是操作的陈列，还没有真正的执行任务。执行任务的部分在下面：

```java
  public JavaTeZhongBing.StringTest();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object."<init>":()V
         4: return
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       5     0  this   LJavaTeZhongBing/StringTest;

```

我们从第一行开始讲解：

`descriptor`：这部分代表是其传入参数为空，有一个空的返回类型(V)。

`flags`：这部分代表这个部分的属性，此处这个部分的属性为 ACC_PUBLIC。

可以看出这个是一个构造方法，虽然我们在程序之中并没显性的定义，但是 Java 会帮助我们生成一个，说明这个动作是在编译的时候完成的。

`stack=1, locals=1, args_size=1`：其中的 Stack 代表栈顶的单位大小（每一个大小为一个 slot），当需要使用一个数据的时候，其首先会被放在栈顶，使用完之后会回写到本地变量或者主存之中。

> 笔者自己的疑问和寻找的方式：
>
> 此处原书之中讲，一个 slot 就是 4个字节宽，但是我有一些疑问：在64位的机器上面，也是一个 slot 32 位吗？查到一些资料，虽然不敢确定，但是对于其中的定义有一些自己的看法：
>
> 参考资料：https://www.cnblogs.com/wuzhiwei549/p/9162673.html
>
> 其中这一段：
>
> 局部变量表的容量以变量槽（Variable Slot）为最小单位，虚拟机规范中并没有明确指明一个Slot暂用的内存空间大小，只是很有“导向性”地说明每个Slot都应该能存放一个boolean,byte,char,short,int,float,refrence,returnAddress类型的数据，这种描述明确指出 “每个Slot占用32位长度的内存空间” 有一些差别，它允许Slot的长度随着处理器，操作系统或虚拟机的不同而发生变化。不过无论如何，即使在64位虚拟机中使用64位长度的内存空间来实现Slot,虚拟机仍要使用对齐和补白的手段让Slot在外观上看起来和32位虚拟机中得一致。
>
> 那么意味着JVM并没对于 slot 的这么一个长度和计算机的位数做一个硬性的规定，而只是规定了其中必须要放得下什么。至于是多少位和数据怎么去处理，是各个 JVM 实现者自己的规定。哪怕是一个 Slot 占有 64位，其也是要使用对齐等等手段使Slot 看起来和 32位之中一致。那么对于JVM而言，32位和 64位的slot就没有必要修改，我个人倾向于在大部分的 JVM 之中slot 的设计还是32位，也就是4字节。希望各位大佬予以指正。

`Stack=1`代表栈顶的单位大小，在写入一个数据的时候，其首先会放入栈顶，使用完会写到本地变量和主存之中。这个栈的宽度是1，意味着有一个 this 将会被使用。

`Locals=1`是本地变量的 slot 个数，但是并不代表着要和Stack的宽度一致。本地变量在这个方法的生命周期之内，局部变量最多的时候，需要多大的宽度来存放数据（double,long 等等会占用两个 slot）。

Args_size 代表的是入口参数的个数，不再是 slot 的个数，即便传入一个 long，这边的记录也只会是1。

`         0: aload_0`

第一个0代表虚指令之中的行号。每个方法从0开始顺序递增，但是可以跳跃，原因在于有一部分的指令还会接操作的内容。这些操作的内容可能来自于**常量池**，也可以标识是第几个 slot的**本地变量**。因此需要占用一部分的空间。

`aload_0`指令是将”第一个“slot所在的本地变量推到栈顶，并且这个本地变量是引用类型的。相关的指令有：aload_[0-3]\(范围是:0x2a~0x2d)。如果超过4个，则会使用 `aload+本地变量的位置`来完成（**此时会占用多一个字节来存放**)，而`aload\_[0-3]`则是通过具体的几个指令直接完成的。其应该是第一个 slot 位置的本地变量。



`         1: invokespecial #1                  // Method java/lang/Object."<init>":()V`

指令之中的第2个行号，执行 invokespecial 指令，当发生构造方法调用、父类的构造方法调用、非静态的private 方法调用的时候会使用该指令。这里要从常量池之中获取一个方法，其会占用2个字节的宽度，加上指令本身就是3个字节，因此下一个的行号是4。

`         4: return`

最后一行是一个 return，虽然没写但是会在JVM 编译的时候帮助我们加上。

```java
     LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       5     0  this   LJavaTeZhongBing/StringTest;
```

代表本地变量的列表，本地变量的作用域的起始位置是0，作用域的宽度是5（0~4），slot的起始位置是0，名称为 this，类型为 LJavaTeZhongBing/StringTest;

下面是main 方法的代码，会使用注释形式在其中讲解：

```java
  public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    //这边指的是一个传入类型为String，返回值类型为void
    flags: ACC_PUBLIC, ACC_STATIC
            //这个方法有public和static的属性。
            Code:
            stack=3, locals=3, args_size=1
            //Stack的3来源是两个Stiring变量，再加上System的out也要占用一个。
            //当发生对比生成boolean的时候，要将两个String的引用从栈顶pop出来，所以栈最多是3个slot。
            //注意此处Locals的值和书上不同，书上是2.此处是3。差别在我这边是main方法，所以多了一个args[]这个变量
            //Arg_size=1也是因为传入参数的个数为1
            0: ldc           #2                  // String ab1
            /**
             * 指令的body部分，第0个字节为 ldc 指令，从常量池入口#2处拿到内容取到栈顶。
             * 虽然String部分也是引用，但是其为常量，所以不使用aload而是使用ldc
             */
            2: astore_1
            /**
             * 将栈顶的引用值放入第2个slot所在的本地变量之中。
             * 注意：此处的作用和之前的 aload 刚好相反。
             * aload 的作用是将本地变量之中的值放到栈顶之中，
             * astore 的作用是将栈顶的slot的值放到本地变量之中。
             * 依笔者个人所见。本地变量的作用类似于变量库，即不需要的变量都存放在里面。
             * 而如果要放到栈之中，就是需要用来做运算的值了。
             * 那么第一个slot之中放入什么呢？看下面的 LocalVariableTable
             * 其中写了第一个 slot 之中的内容是 args。
             */
            3: ldc           #2                  // String ab1
            5: astore_2
            6: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;
            /**
             * 获取静态域，放到栈顶，引用常量池入口 #3来获得
             * 此时的静态域是System类之中的out对象
             */
            9: aload_1
            /**
             * 将第2个slot所在位置的本地引用变量加载到栈顶
             */
            10: aload_2
            11: if_acmpne     18
            14: iconst_1
            15: goto          19
            18: iconst_0
            /**
             * 判定两个栈顶的引用是否一致（引用值也就是地址），对比处理的结束位置是18行
             * 在 if_acmpne 之前，先将两个操作数从栈顶 pop出来，因此栈顶最多是3位
             * 如果一致，则将常量1写入栈顶，对应到 boolean 为 true，并且跳转到19行
             * 如果不一致，则将常量值0 写入栈顶，对应 boolean 值为 false
             */
            19: invokevirtual #4                  // Method java/io/PrintStream.println:(Z)V
            /**
             * 执行 out 对象的 println 对象，方法的参数为 boolean，返回值是 void
             * 从常量池 #4 之中拿到方法的内容实体
             * 此时会将栈顶的元素当做入口参数，栈顶的0或1则会转换成 boolean 值 true，false
             */
            22: return
            LocalVariableTable:
            Start  Length  Slot  Name   Signature
            0      23     0  args   [Ljava/lang/String;
            3      20     1     a   Ljava/lang/String;
            6      17     2     b   Ljava/lang/String;
            /**
             * 本地变量列表，javac 之中需要使用 -g:vars 才会生成，使用一些工具会直接生成。
             * 第一个变量的本地区域是从第0个字节开始，作用的范围是23字节
             * 同理，第二个变量的本地区域从第3个字节开始，作用范围是20 字节。
             */
            StackMapTable: number_of_entries = 2
            frame_type = 255 /* full_frame */
            offset_delta = 18
            locals = [ class "[Ljava/lang/String;", class java/lang/String, class java/lang/String ]
        stack = [ class java/io/PrintStream ]
        frame_type = 255 /* full_frame */
        offset_delta = 0
        locals = [ class "[Ljava/lang/String;", class java/lang/String, class java/lang/String ]
        stack = [ class java/io/PrintStream, int ]
        }

```





