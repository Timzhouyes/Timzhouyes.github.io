---
layout:     post   				    # 使用的布局（不需要改）
title:      一些杂项问题梳理  		# 标题 
subtitle:           #副标题
date:       2020-04-29		# 时间
author:     Haiming 						# 作者
header-img: img/post-bg-2015.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - Programming
---

# 1. WebSocket是什么原理？为何可以实现持久连接？

websocket是一个协议，其是借助HTTP进行连接，在连接完成之后切换成WebSocket协议。

且websocket可以主动推送信息给客户端。

# 2. 什么是JMM？

JMM，Java Memory Model，其是一种符合内存模型规范的，屏蔽了各种硬件和操作系统差异的，保证了Java程序在各种平台下面对内存的访问都能保持一直效果的规范。

其规定了所有的变量都在主内存之中存储，每个线程有自己的工作内存，线程的工作内存之中保存了主内存的副本拷贝，线程对变量的所有操作都必须在工作内存之中进行。不同线程之间无法直接访问对方工作内存之中的变量，线程之间变量的传递都需要自己的工作内存和主存之间进行数据同步进行。

# 3. ping的原理是什么

ping的原理是：对于每个网络上的IP地址，我们都需要去给目标IP地址发送一个数据包，对方也得返回一个同样大小的数据包。那么根据返回的数据包就可以确认对方存在。

# 4. traceroute和原理

**是什么？**

是让我们看到IP数据包从一台主机到另一台主机所经过的路由。

**原理？**

计数多发：将报文之中的TTL字段每次加一并发送，那么就能知道从近到远的IP地址，继续这个过程，直到达到目的主机，那么就知道了所有路径上面的IP地址。

# 5. Spring循环依赖问题与如何解决

Spring之中的循环依赖问题分为三种：

1. 在constautor()之中的循环依赖：没法解决，看到实例化的时候自己在池子之中直接报错
2. 单例模式下的循环依赖：通过三级缓存：
   1. singletonFactories:三级，进入实例化阶段的单例对象工厂的cache
   2. earlySingletonObjects:：二级，**完成实例化**，但是尚未初始化的，提前曝光了的对象的cache
   3. singletonObjects：完成初始化的单例对象的cache（一级缓存）

其中的singletonFactoried的类型是ObjectFactory，定义之中有getObject：

```java
public interface ObjectFactory<T> {
    T getObject() throws BeansException;
}
```

那么在createBeanInstance之后，populateBean()之前，这时候单例对象已经被构造器创建出来了，这个时候将这个对象提前曝光，让大家使用。

3. 非单例循环依赖：无法完成依赖注入，因为Spring不缓存prototype作用域的bean

# 6. Redis如何实现分布式锁

命令之中是`setnx key value`，那么这个时候如果这个key已经有人占用了，就直接返回0.

但是这样会有超时时间的问题，比如线程1拿到了锁，但是死了，那么其他的线程就拿不到锁了。这种情况的对应方式就是设置一个超时时间，expiretime。

看起来完美了？实际不是这样。在java之中设置锁和设置超时时间是分开的，那么如果执行完第一句，拿到锁了之后死了，该怎么办？

两种方法：

1. 使用lua脚本，这样可以保证这个操作的原子性，即一定同时成功或者失败
2. 在value之中放入过期时间，其他机器检查时间是否过期，过期的话就直接`getset jey value`。这个是获取当前key的值，并设置新的值。如果这个返回的值也是过期的，说明修改成功了。没过期，说明自己拿到的锁是别人修改过的，那么自己就不要再去尝试拿锁了。——一点小问题是会延长锁的时间，因为可能getset好几次。但是无伤大雅。

# 7. Collections.sort() 原理

短的时候使用的是归并排序，长的时候是TImSort，就是找到其中有序的子区间，然后直接对两个子区间进行排序。

# 8. Spring有哪些依赖注入方式？都有什么区别？

Spring主要有两种依赖注入方式，其区别在于要不要在初始的时候传参：

1. 构造器注入：容器触发另一个类的**有参构造器**实现的，其有一系列的参数，每个参数都代表一个对于其他类的依赖
2. setter注入：容器调用的是**无参构造器**，然后对于这个bean进行setter的方式来注入

两种依赖方式都可以使用，最好的方案是使用构造器参数实现强制依赖，使用setter注入实现可选依赖。

# 9. Spring 之中的bean的生命周期

1. 从XML或者annotation之中得到bean defination。
2. 使用bean defination 实例化 bean。
3. 根据 bean 的定义填充所有的属性——constructor或者是setter
4. 调用相应的postProcesser 等等，进行AOP注入
5. 实例化 bean，如果有初始化方法，那么调用初始化方法
6. 将初始化之后的bean放入applicationContext之中。

7. 需要的话调用destroy

# 10 反射

反射的主要作用有两个：

1. 创建实例
2. 反射调用方法

首先，当一个类被加载之后，其会产生四个对象：Class,Fields,Methods 和 Constructors。 相当于把类做了一个拆分。

那么怎么用上面的四个类来进行实例创建和方法调用呢？

1. 使用Class对象获取Method的时候，需要传入方法名+参数的Class 类型。 原因是同样的一个方法名可能参数的类型不同，比如在重载的情况下。那么这个时候就得需要传入相应的方法的参数进行比较。
2. 怎么创建一个实例呢？实际上`clazz.getInstance`原理就是调用Constructor对象的newInstance()。所以如果想要使用反射来创建一个新的实例，必须内部有一个无参构造器。
3. 调用method.invoke(obj,args)的时候为什么要传入一个目标对象？因为方法是在方法区之中的，是归属于类的，那么如果指定对象的话，可能会造成操作对象错误情况发生。

# 11. 如何让hashMap线程安全？

1. 使用Collections.synchronizedMap来包装一下，原理就是在某些方法上面加入Synchronized：

   `public static <K,V> Map<K,V> synchronizedMap(Map<K,V> m)`

2. 使用concurrentHashMap

# 12. 什么是Blocking？如何使用？底层原理？

BlockingQueue是一个可以队列满时让生产者阻塞，队列空时让消费者等待，当消费者消费了一个队列中的元素后，会通知生产者当前队列可用的这么一个queue。

其中主要使用的是`put()` 和 `take()`。

原理：

生产者通知消费者可以取数据，或者消费者通知生产者可以拿数据，使用的是Condition。其会满的时候await，但是在消费完一个数据之后发送一个signal。

在向队列之中插入或者取数据的时候，如果队列不可用，那么使用的是LockSupport.park(this)。

顺带一提，可以使用这个机制完成顺序输出123这种的指令。

# 13. MySQL主从复制是全双工还是半双工？

MySQL主从复制之中是半双工的。一旦一端开始发送消息，那么另一端需要等待发送完成之后才能响应它，所以在同步的时候一定要limit好要的信息数量，不然会多传很多冗余信息但是还没法打断。

# 14. 为什么wait是Object的方法？sleep不是？Lock和Condition的用法？

因为synchronized之中的锁可以是任意的Object，所以其是Object的方法。而且后来觉得这样耗费资源（每次notifyAll都是全部线程唤醒），就提出了用Condition之中的await(), signal().signalAll()代替Object中的wait(),notify(),notifyAll()。signal可以唤醒消费方或者是生产方，那么就是有选择的唤醒。



