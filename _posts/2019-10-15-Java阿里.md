---
https://item.taobao.com/item.htm?spm=a230r.1.14.21.26205c81UgA1n4&id=594083406183&ns=1&abbucket=12#detaillayout:     post   				    # 使用的布局（不需要改）
title:      《阿里巴巴Java开发手册》总结与理解				# 标题 
subtitle:   和个人的一些感悟  #副标题
date:       2019-10-15 				# 时间
author:     Haiming 						# 作者
header-img: img/post-bg-2015.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - 编程
    - Java
---
  经各位大佬推荐，想要把 Java 弄明白一点，就看一下《阿里巴巴 Java 开发手册》，那就开始呗。

  看了看发现 《码出高效》 这本书更适合，那就改成看这本书了……

  

# 第一章 计算机基础

以下的基础问题：

- 位移运算可以快速的实现乘除运算，那位移的时候要注意什么？
- 浮点数的存储与计算为什么总会产生微小的误差？
- 乱码产生的根源是什么？
- 代码执行的时候，CPU 是如何配合内存完成工作的？
- 网络链接资源耗尽的本质是什么？

## 1.1 走进 0 和 1 的世界

### 1.1.1 左移/右移 对于数据的修改

左移和右移有两种： << ； >> 和 >>>。

<< 和 >> 代表的是带符号位进行移动。除了右移负数， 高位补 1 之外，其他情况下均在空位上面补0。

![image-20191015113034099](../img/image-20191015113034099.png)

但是左移相对而言就没有上述这种十分确定的关系，原因是：由于符号向左运动，其实不知道是要在移动之后的结果的符号位。 最左位可能是 0 ，可能是 1，那么 **带符号左移** 之后的结果可能和原来不符，出现正数左移是负数，负数左移是正数的情况。

对于 >>> 的这种无符号向右移动，当向右移动的时候，不管正数还是负数，高位全都补 0 。正数不断向右移动的最小值是 0 ， 负数不断向右移动的最小值是 1。 其原因为：实际过程之中，位移运算是先 mod 其位数，然后再进行移动。用 32 位为例， 因为移动的位数是一个 mod 32 的结果，所以 35 >>1 和 35 >> 33 是一样的结果。那么如果一个数 无符号向右移动 63 位的时候，除了最右边是 1 之外，左边全是 0，达到最小值 1，如果 >>> 64， 那么就是原数值本身。

### 1.1.2 浮点数

下面的示例代码显示了浮点数运算之中的误差。

```java
float a = 1f;
float b = 0.9f;

//The result is 0.100000024
float f = a - b;
```

是因为浮点数按理来讲，只可以表示 2^n 的数，n 可以为正数或者负数等等。但是 0.9 无法用有限的二进制位进行精确表示，所以 1-0.9 并不精确的等于 0.1 。

![image-20191015133418958](../img/image-20191015133418958.png)

**浮点数如何进行加减运算**

- 在浮点数进行加减运算的时候，首先要将小数点对齐，然后同位数进行加减运算。 在 浮点数 之中，规定了阶码和尾数 都是0 的数就是0 。如果其中一个数是0， 则直接得到结果。

- 在对阶的过程中，有一部分二进制位会被移除，由于上面的定义，我们可知，左移和右移的影响不同，右移只是一部分小数位会被移除，但是左移的话高位会被移除。所以 IEEE754 规定的是，选择阶码小的数进行右移操作。
- 然后便是直接求和和结果规格化。结果规格化之中，如果运算的结果不满足规格化的形式，那么会通过尾数的左移或者右移来达到规格化形式。
- 由于在第二步之中，我们讲了有“右移操作”，但是最终被移除去的位数不可以丢弃，其在规格化之中再做舍入处理。

**浮点数要求注意的点**

- 在昨天的博文之中也提到过，像货币等等要求绝对精确的情况下，推荐使用整型来表示其最小单位的值。
- 在要求精确表示小数点后n位的情况下，比如圆周率的小数点后 n 位数字，可以使用数组来保存小数部分的数据。
- 由于之前的例子，可以看到在比较浮点数的时候，往往存在误差，因此禁止使用比较某些浮点数是否相等来控制业务流程。
- 数据库之中，保存小数的时候，推荐使用 decimal 类型，禁止使用 float 类型和 double 类型。禁止使用这两种类型的原因也是因为其存在精度损失的问题。

### 1.1.3 字符集和乱码

当前编码环境之中推荐的换行方式是 LF， 也就是\r\n

汉字的实现编码标准有很多，几个比较典型的有：GB2312,GBK 还有 UTF。

我对 UTF-8 的定界很感兴趣，下面是一点小研究：