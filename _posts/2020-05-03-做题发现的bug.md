---
layout:     post   				    # 使用的布局（不需要改）
title:      记录一下做题时候发现的一个小盲点  		# 标题 
subtitle:   二分法求整数的平方根        #副标题
date:       2020-05-03		# 时间
author:     Haiming 						# 作者
header-img: img/post-bg-2015.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - Programming
    - LeetCode
---

晚上在看题目的时候发现了自己对于数据溢出的一个小盲点，算是平时不会考虑到的一个小方面吧，做个记录

题目地址：https://leetcode.com/problems/sqrtx/

题目很简单，就是二分法查找一个整数的平方根，根据其值相乘的结果和传入的值的关系比较，来不断的缩小区间范围。可是下面两个版本的代码，第一个可以通过，第二个就不行。

可通过版本(其中有调试代码）：

```java
   public static  int mySqrt(int x) {
        if (x == 0 || x == 1) return x;
        int mid, left = 1, right = x;
        while (left < right) {
            mid = left + (right - left) / 2;
            if (mid > x / mid) {
                if (mid * mid <= x) {
                    System.out.println("mid is " + mid + " x is " + x + " mid * mid is "+mid*mid);
                    System.out.println("x/mid is "+x/mid + " mid is "+mid+'\t');
                }
                right = mid - 1;
            } else if (mid == x / mid)
                return mid;
            else {
                if ((mid + 1) > x / (mid + 1))
                    return mid;
                if ((mid + 1) == x / (mid + 1))
                    return mid + 1;
                left = mid + 1;
            }
        }
        return (left + right) / 2;
    }
```

不可通过版本：

```java
class Solution {
    
    public int mySqrt(int x)   { 
        // Base Cases 
        if (x == 0 || x == 1) 
            return x; 
  
        // Do Binary Search for floor(sqrt(x)) 
        int start = 1, end = x, ans=0; 
        while (start <= end) 
        { 
            int mid = (start + end) / 2; 
  
            // If x is a perfect square 
            if (mid*mid == x) 
                return mid; 
  
            // Since we need floor, we update answer when mid*mid is 
            // smaller than x, and move closer to sqrt(x) 
            if (mid*mid < x) 
            { 
                start = mid + 1; 
                ans = mid; 
            } 
            else   // If mid*mid is greater than x 
                end = mid-1; 
        } 
        return ans; 
    } 
    
}
```

二者看起来没有任何不同，只是一个判断的时候判断的是`mid * mid`和x的关系，而另一个判断的时候是`mid`和 `x / mid`的关系。都是求非负整数的值，那么这两者之间应该是一样的啊？怎么一个可以一个不行呢？

再给个提示：

![image-20200503203940712](../img/image-20200503203940712.png)

这是出错时候的情况。

很奇怪吧？怎么会出现负数的输出？

问题就在这！

因为int的范围是有限的，只有4个字节，那么其可以表示的范围就是-2147483648~2147483647。

我们随便挑一行测试代码的输出：

```java
mid is 46341 x is 2147395599 mid * mid is -2147479015
x/mid is 46339 mid is 46341	
```

看到没有，此处的`mid * mid` 是负值！原因是 `46341 * 46341 = 2147488281`，这个已经超过了int 的表示范围，那么截断之后就出现其为负值的情况。

深刻体会到了范围的重要性……

