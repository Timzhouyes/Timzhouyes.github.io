---
layout:     post   				    # 使用的布局（不需要改）
title:      重新梳理计算机基础  		# 标题 
subtitle:   包括Java，数据库        #副标题
date:       2020-04-12		# 时间
author:     Haiming 						# 作者
header-img: img/post-bg-2015.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - Programming
    - Java
    - MySQL
---

# 1. Java

## 1.1 面向对象一定比面向过程性能差吗？

# 2. MySQL

## 2.1 什么是聚簇索引？什么是非聚簇索引？二者之间的区别在于哪？

在InnoDB 之中使用的是聚簇索引， 在MyISAM 之中使用的是非聚簇索引。二者之间的区别主要在于B+树的子节点上面是否有完整的整条数据。见下图：

![image-20200413201223230](../img/image-20200413201223230.png)

左边的是聚簇索引， 右边的是非聚簇索引。对于非聚簇索引而言，一级索引和二级索引区别不大，都是在最下面的节点之中存储其索引的地址，然后去数据部分查找。但是聚簇索引而言，一级索引的叶子节点上面是有完整的整条数据的，二级索引之中是部分数据和一级索引的key，在二级索引之中查找，需要先拿到对应的key，然后去一级索引之中拿到其中的值。

**聚簇索引和非聚簇索引之间的区别在哪？**

聚簇索引的优点：

1. 可以更方便的查找一个范围的值。
2. 在查找时候会更快，省去了一次由key去磁盘找到对应数据的IO
3. 如果使用覆盖索引，那么不用再去查大表，更快。

聚簇索引的缺点：

千万不能改主键！！！！

1. 为啥主键非得自增？不然的话每次插入都得对于所有数据进行重排，其代价是不可接受的。

2. 二级索引需要查找两次，其在二级索引之中加入的是一级索引的key的原因是避免重排导致的维护工作，但是查找时候需要查找两次。
3. 插入新值的速度慢很多。因为要确认其ID是否唯一，但是判断方式在不同的索引下面有很大差距。由于InnoDB之中的叶子节点上面有很多数据，因此遍历的过程也会慢很多。

## 2.2 都有哪些索引类型呢？

1. 从数据结构角度：hash索引，B+树索引，全文索引。
2. 从物理存储角度：聚簇索引，非聚簇索引
3. 从逻辑角度：普通索引，组合索引

# 3. 数据结构

## 3.1 ConcurrentHashmap

https://www.cnblogs.com/zerotomax/p/8687425.html

## 3.2 Queue和Stack

Queue在Java之中只是一个接口，如图：

![image-20200414091642240](../img/image-20200414091642240.png)

但是Stack却是一个类，比如：

![image-20200414091720963](../img/image-20200414091720963.png)

两种实现方式的不同就确定了其使用方式的不同：

对于Queue而言，其要使用LinkedList来实现，其实Queue就是将LinkedList 之中的方法限定成只有queue之中有的:

1. boolean add(T t): 其作用是加入一个元素，要么返回true，要么抛出Exception。其是直接继承的Collection之中的方法；和boolean offer()相比，offer() 是在其正确插入的情况下返回true，非正确插入的情况下返回false。
2. T remove(): 一般都是辨析其和 poll() 的区别，其中主要区别就是当Queue为空的时候，poll() 返回的是null，但是remove直接抛出异常。
3. T peek(): 返回头部的元素，其和remove() 的区别在于其不会删除头部的元素，peek，看一看之意。

但是对于Stack而言，其是一个类，所以可以直接实例化：

1. T pop(): 和remove一样
2. T push(): 和add一样，但是其返回值是刚刚加入的这个值。
3. T peek(): 瞧一眼栈顶元素，和之前讲的是一样的。

### 3.2.1 如何使用stack实现queue? 如何使用queue实现stack？

**如何使用stack实现queue？Leetcode 232**

用两个栈，一个instack,一个outstack。每次都只对instack做操作，除了queue的add方法：

先将instack全都pop到outstack 之中，然后将值push进outstack 之中。最后将outstack 之中的值全都pop()进instack,那么最先加入的值就会在instack的最下方

```java
class MyQueue {
    Stack<Integer> instack;
    Stack<Integer> outstack;
    /** Initialize your data structure here. */
    public MyQueue() {
        instack = new Stack<Integer>();
        outstack = new Stack<Integer>();
    }
    
    /** Push element x to the back of queue. */
    public void push(int x) {
        while(!instack.isEmpty()){
            outstack.push(instack.pop());
        }
        outstack.push(x);
        while(!outstack.isEmpty()){
            instack.push(outstack.pop());
        }
    }
    
    /** Removes the element from in front of queue and returns that element. */
    public int pop() {
            return instack.pop();
       
    }
    
    /** Get the front element. */
    public int peek() {
        return instack.peek();
    }
    
    /** Returns whether the queue is empty. */
    public boolean empty() {
        return instack.isEmpty() && outstack.isEmpty();
    }
}

/**
 * Your MyQueue object will be instantiated and called as such:
 * MyQueue obj = new MyQueue();
 * obj.push(x);
 * int param_2 = obj.pop();
 * int param_3 = obj.peek();
 * boolean param_4 = obj.empty();
 */
```

**如何使用queue实现stack？**

每次先加入一个数，此时的数在queue的末尾，然后:

```java
public void push(int x) {
        queue.add(x);
        int size = queue.size();
        while(size>1){
            queue.add(queue.remove());
            size--;
        }
    }
```

这样循环操作就可以了。其他的都是单步操作。

