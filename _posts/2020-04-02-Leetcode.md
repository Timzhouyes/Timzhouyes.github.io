---
layout:     post   				    # 使用的布局（不需要改）
title:      LeetCode心得  		# 标题 
subtitle:   在刷题之中遇到的好问题心得        #副标题
date:       2020-04-02		# 时间
author:     Haiming 						# 作者
header-img: img/post-bg-2015.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - Programming
    - LeetCode
---

此处主要是记录一些自己觉得精彩的LeetCode题解和心得。

# 136.Single Number

https://leetcode.com/problems/single-number/

本题精彩之处在于要求时间复杂度O(n),而且要求不可以使用额外空间，空间复杂度为O(1)。这就断了我们使用排序或者是hashMap来解决的路。本题之中使用二进制异或的性质来完成，所有数字异或之后就是结果。

为什么可以用异或来完成数字之间的比较？

1. 0和任何数异或都是其本身，那么我们就可以使用0作为函数的初始条件。
2. 任何数和本身异或都是0， 那么两个相同的数异或之后可以抵消。

先说下这个抵消的问题：

计算机之中都是使用二进制的，我们来做个示例就知道这种抵消效应了：

假设为[6,2,6],那么

6=0110

2=0010

6 ^ 2 = 0100 = 4

0100 ^ 6 = 0100 ^ 0110 = 0010 = 2

你看，回来了不是。

```java
class Solution {
    public int singleNumber(int[] nums) {
        int result = 0;
        for(int i :nums){
            result = result ^ i;
        }
        return result;
    }
}
```



