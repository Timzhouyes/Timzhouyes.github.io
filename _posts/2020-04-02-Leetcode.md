---
layout:     post   				    # 使用的布局（不需要改）
title:      LeetCode心得  		# 标题 
subtitle:   在刷题之中遇到的好问题心得        #副标题
date:       2020-04-02		# 时间
author:     Haiming 						# 作者
header-img: img/post-bg-2015.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - Programming
    - LeetCode
---

此处主要是记录一些自己觉得精彩的LeetCode题解和心得。

# 1. Tree

## 136.Single Number

https://leetcode.com/problems/single-number/

本题精彩之处在于要求时间复杂度O(n),而且要求不可以使用额外空间，空间复杂度为O(1)。这就断了我们使用排序或者是hashMap来解决的路。本题之中使用二进制异或的性质来完成，所有数字异或之后就是结果。

为什么可以用异或来完成数字之间的比较？

1. 0和任何数异或都是其本身，那么我们就可以使用0作为函数的初始条件。
2. 任何数和本身异或都是0， 那么两个相同的数异或之后可以抵消。

先说下这个抵消的问题：

计算机之中都是使用二进制的，我们来做个示例就知道这种抵消效应了：

假设为[6,2,6],那么

6=0110

2=0010

6 ^ 2 = 0100 = 4

0100 ^ 6 = 0100 ^ 0110 = 0010 = 2

你看，回来了不是。

```java
class Solution {
    public int singleNumber(int[] nums) {
        int result = 0;
        for(int i :nums){
            result = result ^ i;
        }
        return result;
    }
}
```

## 513. Find Bottom Left Tree Value (Easy)

本题之中我认为最有趣的是其活用了Queue的先入先出后入后出的性质。通过每次入队时候先入右边节点再入左边节点，那么最后剩下的一定是“最底层的最左边的节点”。



## 637. Average of Levels in Binary Tree 

https://leetcode.com/problems/average-of-levels-in-binary-tree/

本题的亮点在于其不需要另外一个ArrayList来存储每一层之中的节点，而是可以通过控制遍历时候的长度来实现分层的作用。

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public List<Double> averageOfLevels(TreeNode root) {
        ArrayList<Double> list = new ArrayList<>();
        if(root == null) return list;
        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root);
        while(!queue.isEmpty()){
            double num = 0;
            int length = queue.size();
            for(int i=0;i<length;i++){
                TreeNode item = queue.poll();
                num+=item.val;
                if(item.left!=null) queue.add(item.left);
                if(item.right!=null) queue.add(item.right);
            }
            num = num/length;
            list.add(num);
        }
        
        return list;
    }
}
```

# 